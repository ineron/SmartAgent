/* soapC.cpp
   Generated by gSOAP 2.8.14 from soap.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.14 2015-01-22 13:29:19 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__StandardPeriodVariant:
		return soap_in_ns2__StandardPeriodVariant(soap, NULL, NULL, "ns2:StandardPeriodVariant");
	case SOAP_TYPE_ns2__StandardBeginningDateVariant:
		return soap_in_ns2__StandardBeginningDateVariant(soap, NULL, NULL, "ns2:StandardBeginningDateVariant");
	case SOAP_TYPE_ns2__FillChecking:
		return soap_in_ns2__FillChecking(soap, NULL, NULL, "ns2:FillChecking");
	case SOAP_TYPE_ns2__FillCheckErrorStatus:
		return soap_in_ns2__FillCheckErrorStatus(soap, NULL, NULL, "ns2:FillCheckErrorStatus");
	case SOAP_TYPE_ns2__DateFractions:
		return soap_in_ns2__DateFractions(soap, NULL, NULL, "ns2:DateFractions");
	case SOAP_TYPE_ns2__AllowedSign:
		return soap_in_ns2__AllowedSign(soap, NULL, NULL, "ns2:AllowedSign");
	case SOAP_TYPE_ns2__AllowedLength:
		return soap_in_ns2__AllowedLength(soap, NULL, NULL, "ns2:AllowedLength");
	case SOAP_TYPE_ns2__ValueStorage:
		return soap_in_ns2__ValueStorage(soap, NULL, NULL, "ns2:ValueStorage");
	case SOAP_TYPE_ns2__UUID:
		return soap_in_ns2__UUID(soap, NULL, NULL, "ns2:UUID");
	case SOAP_TYPE_ns2__Type:
		return soap_in_ns2__Type(soap, NULL, NULL, "ns2:Type");
	case SOAP_TYPE_ns2__Null:
		return soap_in_ns2__Null(soap, NULL, NULL, "ns2:Null");
	case SOAP_TYPE_ns2__CompositeID:
		return soap_in_ns2__CompositeID(soap, NULL, NULL, "ns2:CompositeID");
	case SOAP_TYPE_ns2__ValueTreeRow:
		return soap_in_ns2__ValueTreeRow(soap, NULL, NULL, "ns2:ValueTreeRow");
	case SOAP_TYPE_ns2__ValueTreeColumn:
		return soap_in_ns2__ValueTreeColumn(soap, NULL, NULL, "ns2:ValueTreeColumn");
	case SOAP_TYPE_ns2__ValueTree:
		return soap_in_ns2__ValueTree(soap, NULL, NULL, "ns2:ValueTree");
	case SOAP_TYPE_ns2__ValueTableRow:
		return soap_in_ns2__ValueTableRow(soap, NULL, NULL, "ns2:ValueTableRow");
	case SOAP_TYPE_ns2__ValueTableIndex:
		return soap_in_ns2__ValueTableIndex(soap, NULL, NULL, "ns2:ValueTableIndex");
	case SOAP_TYPE_ns2__ValueTableColumn:
		return soap_in_ns2__ValueTableColumn(soap, NULL, NULL, "ns2:ValueTableColumn");
	case SOAP_TYPE_ns2__ValueTable:
		return soap_in_ns2__ValueTable(soap, NULL, NULL, "ns2:ValueTable");
	case SOAP_TYPE_ns2__ValueListType:
		return soap_in_ns2__ValueListType(soap, NULL, NULL, "ns2:ValueListType");
	case SOAP_TYPE_ns2__ValueListItemType:
		return soap_in_ns2__ValueListItemType(soap, NULL, NULL, "ns2:ValueListItemType");
	case SOAP_TYPE_ns2__TypeDescription:
		return soap_in_ns2__TypeDescription(soap, NULL, NULL, "ns2:TypeDescription");
	case SOAP_TYPE_ns2__Structure:
		return soap_in_ns2__Structure(soap, NULL, NULL, "ns2:Structure");
	case SOAP_TYPE_ns2__StringQualifiers:
		return soap_in_ns2__StringQualifiers(soap, NULL, NULL, "ns2:StringQualifiers");
	case SOAP_TYPE_ns2__StandardPeriod:
		return soap_in_ns2__StandardPeriod(soap, NULL, NULL, "ns2:StandardPeriod");
	case SOAP_TYPE_ns2__StandardBeginningDate:
		return soap_in_ns2__StandardBeginningDate(soap, NULL, NULL, "ns2:StandardBeginningDate");
	case SOAP_TYPE_ns2__NumberQualifiers:
		return soap_in_ns2__NumberQualifiers(soap, NULL, NULL, "ns2:NumberQualifiers");
	case SOAP_TYPE_ns2__Map:
		return soap_in_ns2__Map(soap, NULL, NULL, "ns2:Map");
	case SOAP_TYPE_ns2__LocalStringType:
		return soap_in_ns2__LocalStringType(soap, NULL, NULL, "ns2:LocalStringType");
	case SOAP_TYPE_ns2__LocalStringItemType:
		return soap_in_ns2__LocalStringItemType(soap, NULL, NULL, "ns2:LocalStringItemType");
	case SOAP_TYPE_ns2__KeyAndValue:
		return soap_in_ns2__KeyAndValue(soap, NULL, NULL, "ns2:KeyAndValue");
	case SOAP_TYPE_ns2__GenericException:
		return soap_in_ns2__GenericException(soap, NULL, NULL, "ns2:GenericException");
	case SOAP_TYPE_ns2__FixedStructure:
		return soap_in_ns2__FixedStructure(soap, NULL, NULL, "ns2:FixedStructure");
	case SOAP_TYPE_ns2__FixedMap:
		return soap_in_ns2__FixedMap(soap, NULL, NULL, "ns2:FixedMap");
	case SOAP_TYPE_ns2__FixedArray:
		return soap_in_ns2__FixedArray(soap, NULL, NULL, "ns2:FixedArray");
	case SOAP_TYPE_ns2__Exception:
		return soap_in_ns2__Exception(soap, NULL, NULL, "ns2:Exception");
	case SOAP_TYPE_ns2__DateQualifiers:
		return soap_in_ns2__DateQualifiers(soap, NULL, NULL, "ns2:DateQualifiers");
	case SOAP_TYPE_ns2__DataFillErrors:
		return soap_in_ns2__DataFillErrors(soap, NULL, NULL, "ns2:DataFillErrors");
	case SOAP_TYPE_ns2__DataFillError:
		return soap_in_ns2__DataFillError(soap, NULL, NULL, "ns2:DataFillError");
	case SOAP_TYPE_ns2__BinaryDataQualifiers:
		return soap_in_ns2__BinaryDataQualifiers(soap, NULL, NULL, "ns2:BinaryDataQualifiers");
	case SOAP_TYPE_ns2__Array:
		return soap_in_ns2__Array(soap, NULL, NULL, "ns2:Array");
	case SOAP_TYPE_ns1__Structure:
		return soap_in_ns1__Structure(soap, NULL, NULL, "ns1:Structure");
	case SOAP_TYPE_ns1__Object:
		return soap_in_ns1__Object(soap, NULL, NULL, "ns1:Object");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__QueryUniversalResponse:
		return soap_in_PointerTo_ns1__QueryUniversalResponse(soap, NULL, NULL, "ns1:QueryUniversalResponse");
	case SOAP_TYPE_PointerTo_ns1__QueryUniversal:
		return soap_in_PointerTo_ns1__QueryUniversal(soap, NULL, NULL, "ns1:QueryUniversal");
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		return soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, NULL, NULL, "ns1:ЗаписатьДанныеResponse");
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		return soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, NULL, NULL, "ns1:ЗаписатьДанные");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		return soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, NULL, NULL, "ns1:ЦеныНоменклатурыПоПериодамResponse");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		return soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, NULL, NULL, "ns1:ЦеныНоменклатурыПоПериодам");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		return soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, NULL, NULL, "ns1:ЦеныНоменклатурыПоГТДResponse");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		return soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, NULL, NULL, "ns1:ЦеныНоменклатурыПоГТД");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, "ns1:РасширенныйЗапросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, NULL, NULL, "ns1:РасширенныйЗапрос");
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, "ns1:УниверсальныйЗапросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, NULL, NULL, "ns1:УниверсальныйЗапрос");
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		return soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, NULL, NULL, "ns1:ТоварыВПутиResponse");
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		return soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, NULL, NULL, "ns1:ТоварыВПути");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, "ns1:РасчитатьАномальныйСпросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, NULL, NULL, "ns1:РасчитатьАномальныйСпрос");
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		return soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, NULL, NULL, "ns1:ПродажиResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		return soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, NULL, NULL, "ns1:Продажи");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		return soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, NULL, NULL, "ns1:ПолучитьЦеныНоменклатурыResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		return soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, NULL, NULL, "ns1:ПолучитьЦеныНоменклатуры");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		return soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, NULL, NULL, "ns1:ПолучитьКурсыВалютResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		return soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, NULL, NULL, "ns1:ПолучитьКурсыВалют");
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		return soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, NULL, NULL, "ns1:ОстаткиResponse");
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		return soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, NULL, NULL, "ns1:Остатки");
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, "ns1:НеВыполненныйСпросResponse");
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, NULL, NULL, "ns1:НеВыполненныйСпрос");
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		return soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, NULL, NULL, "ns1:ИнформационныеБазыResponse");
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		return soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, NULL, NULL, "ns1:ИнформационныеБазы");
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		return soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, NULL, NULL, "ns1:ДниОтсутствияResponse");
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		return soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, NULL, NULL, "ns1:ДниОтсутствия");
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfoResponse:
		return soap_in_PointerTo_ns1__GetStructureInfoResponse(soap, NULL, NULL, "ns1:GetStructureInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfo:
		return soap_in_PointerTo_ns1__GetStructureInfo(soap, NULL, NULL, "ns1:GetStructureInfo");
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoodsResponse:
		return soap_in_PointerTo_ns1__GetAmountGoodsResponse(soap, NULL, NULL, "ns1:GetAmountGoodsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoods:
		return soap_in_PointerTo_ns1__GetAmountGoods(soap, NULL, NULL, "ns1:GetAmountGoods");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons2__ValueTreeRow:
		return soap_in_PointerTons2__ValueTreeRow(soap, NULL, NULL, "ns2:ValueTreeRow");
	case SOAP_TYPE_PointerTons2__ValueTreeColumn:
		return soap_in_PointerTons2__ValueTreeColumn(soap, NULL, NULL, "ns2:ValueTreeColumn");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_in_PointerToxsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons2__ValueTableRow:
		return soap_in_PointerTons2__ValueTableRow(soap, NULL, NULL, "ns2:ValueTableRow");
	case SOAP_TYPE_PointerTons2__ValueTableIndex:
		return soap_in_PointerTons2__ValueTableIndex(soap, NULL, NULL, "ns2:ValueTableIndex");
	case SOAP_TYPE_PointerTons2__ValueTableColumn:
		return soap_in_PointerTons2__ValueTableColumn(soap, NULL, NULL, "ns2:ValueTableColumn");
	case SOAP_TYPE_PointerTons2__ValueListItemType:
		return soap_in_PointerTons2__ValueListItemType(soap, NULL, NULL, "ns2:ValueListItemType");
	case SOAP_TYPE_PointerTons2__TypeDescription:
		return soap_in_PointerTons2__TypeDescription(soap, NULL, NULL, "ns2:TypeDescription");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__BinaryDataQualifiers:
		return soap_in_PointerTons2__BinaryDataQualifiers(soap, NULL, NULL, "ns2:BinaryDataQualifiers");
	case SOAP_TYPE_PointerTons2__DateQualifiers:
		return soap_in_PointerTons2__DateQualifiers(soap, NULL, NULL, "ns2:DateQualifiers");
	case SOAP_TYPE_PointerTons2__StringQualifiers:
		return soap_in_PointerTons2__StringQualifiers(soap, NULL, NULL, "ns2:StringQualifiers");
	case SOAP_TYPE_PointerTons2__NumberQualifiers:
		return soap_in_PointerTons2__NumberQualifiers(soap, NULL, NULL, "ns2:NumberQualifiers");
	case SOAP_TYPE_PointerTons2__LocalStringItemType:
		return soap_in_PointerTons2__LocalStringItemType(soap, NULL, NULL, "ns2:LocalStringItemType");
	case SOAP_TYPE_PointerTons2__GenericException:
		return soap_in_PointerTons2__GenericException(soap, NULL, NULL, "ns2:GenericException");
	case SOAP_TYPE_PointerTons2__KeyAndValue:
		return soap_in_PointerTons2__KeyAndValue(soap, NULL, NULL, "ns2:KeyAndValue");
	case SOAP_TYPE_PointerTons2__DataFillError:
		return soap_in_PointerTons2__DataFillError(soap, NULL, NULL, "ns2:DataFillError");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__ValueTree:
		return soap_in_PointerTons2__ValueTree(soap, NULL, NULL, "ns2:ValueTree");
	case SOAP_TYPE_PointerTons2__ValueListType:
		return soap_in_PointerTons2__ValueListType(soap, NULL, NULL, "ns2:ValueListType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__ValueTable:
		return soap_in_PointerTons2__ValueTable(soap, NULL, NULL, "ns2:ValueTable");
	case SOAP_TYPE_PointerTons2__Structure:
		return soap_in_PointerTons2__Structure(soap, NULL, NULL, "ns2:Structure");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__Object:
		return soap_in_PointerTons1__Object(soap, NULL, NULL, "ns1:Object");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:ValueStorage"))
		{	*type = SOAP_TYPE_ns2__ValueStorage;
			return soap_in_ns2__ValueStorage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UUID"))
		{	*type = SOAP_TYPE_ns2__UUID;
			return soap_in_ns2__UUID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Type"))
		{	*type = SOAP_TYPE_ns2__Type;
			return soap_in_ns2__Type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Null"))
		{	*type = SOAP_TYPE_ns2__Null;
			return soap_in_ns2__Null(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CompositeID"))
		{	*type = SOAP_TYPE_ns2__CompositeID;
			return soap_in_ns2__CompositeID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTreeRow"))
		{	*type = SOAP_TYPE_ns2__ValueTreeRow;
			return soap_in_ns2__ValueTreeRow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTreeColumn"))
		{	*type = SOAP_TYPE_ns2__ValueTreeColumn;
			return soap_in_ns2__ValueTreeColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTree"))
		{	*type = SOAP_TYPE_ns2__ValueTree;
			return soap_in_ns2__ValueTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTableRow"))
		{	*type = SOAP_TYPE_ns2__ValueTableRow;
			return soap_in_ns2__ValueTableRow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTableIndex"))
		{	*type = SOAP_TYPE_ns2__ValueTableIndex;
			return soap_in_ns2__ValueTableIndex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTableColumn"))
		{	*type = SOAP_TYPE_ns2__ValueTableColumn;
			return soap_in_ns2__ValueTableColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueTable"))
		{	*type = SOAP_TYPE_ns2__ValueTable;
			return soap_in_ns2__ValueTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueListType"))
		{	*type = SOAP_TYPE_ns2__ValueListType;
			return soap_in_ns2__ValueListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValueListItemType"))
		{	*type = SOAP_TYPE_ns2__ValueListItemType;
			return soap_in_ns2__ValueListItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TypeDescription"))
		{	*type = SOAP_TYPE_ns2__TypeDescription;
			return soap_in_ns2__TypeDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Structure"))
		{	*type = SOAP_TYPE_ns2__Structure;
			return soap_in_ns2__Structure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StringQualifiers"))
		{	*type = SOAP_TYPE_ns2__StringQualifiers;
			return soap_in_ns2__StringQualifiers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StandardPeriod"))
		{	*type = SOAP_TYPE_ns2__StandardPeriod;
			return soap_in_ns2__StandardPeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StandardBeginningDate"))
		{	*type = SOAP_TYPE_ns2__StandardBeginningDate;
			return soap_in_ns2__StandardBeginningDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NumberQualifiers"))
		{	*type = SOAP_TYPE_ns2__NumberQualifiers;
			return soap_in_ns2__NumberQualifiers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Map"))
		{	*type = SOAP_TYPE_ns2__Map;
			return soap_in_ns2__Map(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LocalStringType"))
		{	*type = SOAP_TYPE_ns2__LocalStringType;
			return soap_in_ns2__LocalStringType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LocalStringItemType"))
		{	*type = SOAP_TYPE_ns2__LocalStringItemType;
			return soap_in_ns2__LocalStringItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:KeyAndValue"))
		{	*type = SOAP_TYPE_ns2__KeyAndValue;
			return soap_in_ns2__KeyAndValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GenericException"))
		{	*type = SOAP_TYPE_ns2__GenericException;
			return soap_in_ns2__GenericException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FixedStructure"))
		{	*type = SOAP_TYPE_ns2__FixedStructure;
			return soap_in_ns2__FixedStructure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FixedMap"))
		{	*type = SOAP_TYPE_ns2__FixedMap;
			return soap_in_ns2__FixedMap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FixedArray"))
		{	*type = SOAP_TYPE_ns2__FixedArray;
			return soap_in_ns2__FixedArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Exception"))
		{	*type = SOAP_TYPE_ns2__Exception;
			return soap_in_ns2__Exception(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DateQualifiers"))
		{	*type = SOAP_TYPE_ns2__DateQualifiers;
			return soap_in_ns2__DateQualifiers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataFillErrors"))
		{	*type = SOAP_TYPE_ns2__DataFillErrors;
			return soap_in_ns2__DataFillErrors(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataFillError"))
		{	*type = SOAP_TYPE_ns2__DataFillError;
			return soap_in_ns2__DataFillError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BinaryDataQualifiers"))
		{	*type = SOAP_TYPE_ns2__BinaryDataQualifiers;
			return soap_in_ns2__BinaryDataQualifiers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Array"))
		{	*type = SOAP_TYPE_ns2__Array;
			return soap_in_ns2__Array(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Structure"))
		{	*type = SOAP_TYPE_ns1__Structure;
			return soap_in_ns1__Structure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Object"))
		{	*type = SOAP_TYPE_ns1__Object;
			return soap_in_ns1__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StandardPeriodVariant"))
		{	*type = SOAP_TYPE_ns2__StandardPeriodVariant;
			return soap_in_ns2__StandardPeriodVariant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StandardBeginningDateVariant"))
		{	*type = SOAP_TYPE_ns2__StandardBeginningDateVariant;
			return soap_in_ns2__StandardBeginningDateVariant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillChecking"))
		{	*type = SOAP_TYPE_ns2__FillChecking;
			return soap_in_ns2__FillChecking(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillCheckErrorStatus"))
		{	*type = SOAP_TYPE_ns2__FillCheckErrorStatus;
			return soap_in_ns2__FillCheckErrorStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DateFractions"))
		{	*type = SOAP_TYPE_ns2__DateFractions;
			return soap_in_ns2__DateFractions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AllowedSign"))
		{	*type = SOAP_TYPE_ns2__AllowedSign;
			return soap_in_ns2__AllowedSign(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AllowedLength"))
		{	*type = SOAP_TYPE_ns2__AllowedLength;
			return soap_in_ns2__AllowedLength(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:Structure-Property"))
		{	*type = SOAP_TYPE__ns2__Structure_Property;
			return soap_in__ns2__Structure_Property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FixedStructure-Property"))
		{	*type = SOAP_TYPE__ns2__FixedStructure_Property;
			return soap_in__ns2__FixedStructure_Property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryUniversalResponse"))
		{	*type = SOAP_TYPE__ns1__QueryUniversalResponse;
			return soap_in__ns1__QueryUniversalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryUniversal"))
		{	*type = SOAP_TYPE__ns1__QueryUniversal;
			return soap_in__ns1__QueryUniversal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЗаписатьДанныеResponse"))
		{	*type = SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response;
			return soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЗаписатьДанные"))
		{	*type = SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435;
			return soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЦеныНоменклатурыПоПериодамResponse"))
		{	*type = SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse;
			return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЦеныНоменклатурыПоПериодам"))
		{	*type = SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c;
			return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЦеныНоменклатурыПоГТДResponse"))
		{	*type = SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response;
			return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ЦеныНоменклатурыПоГТД"))
		{	*type = SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414;
			return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:РасширенныйЗапросResponse"))
		{	*type = SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response;
			return soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:РасширенныйЗапрос"))
		{	*type = SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441;
			return soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:УниверсальныйЗапросResponse"))
		{	*type = SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response;
			return soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:УниверсальныйЗапрос"))
		{	*type = SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441;
			return soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ТоварыВПутиResponse"))
		{	*type = SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response;
			return soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ТоварыВПути"))
		{	*type = SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438;
			return soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:РасчитатьАномальныйСпросResponse"))
		{	*type = SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response;
			return soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:РасчитатьАномальныйСпрос"))
		{	*type = SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441;
			return soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПродажиResponse"))
		{	*type = SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response;
			return soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Продажи"))
		{	*type = SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438;
			return soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПолучитьЦеныНоменклатурыResponse"))
		{	*type = SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse;
			return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПолучитьЦеныНоменклатуры"))
		{	*type = SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b;
			return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПолучитьКурсыВалютResponse"))
		{	*type = SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response;
			return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПолучитьКурсыВалют"))
		{	*type = SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442;
			return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ОстаткиResponse"))
		{	*type = SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response;
			return soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Остатки"))
		{	*type = SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438;
			return soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:НеВыполненныйСпросResponse"))
		{	*type = SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response;
			return soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:НеВыполненныйСпрос"))
		{	*type = SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441;
			return soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ИнформационныеБазыResponse"))
		{	*type = SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse;
			return soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ИнформационныеБазы"))
		{	*type = SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b;
			return soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ДниОтсутствияResponse"))
		{	*type = SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse;
			return soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ДниОтсутствия"))
		{	*type = SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f;
			return soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStructureInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetStructureInfoResponse;
			return soap_in__ns1__GetStructureInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStructureInfo"))
		{	*type = SOAP_TYPE__ns1__GetStructureInfo;
			return soap_in__ns1__GetStructureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAmountGoodsResponse"))
		{	*type = SOAP_TYPE__ns1__GetAmountGoodsResponse;
			return soap_in__ns1__GetAmountGoodsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAmountGoods"))
		{	*type = SOAP_TYPE__ns1__GetAmountGoods;
			return soap_in__ns1__GetAmountGoods(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns2__StandardPeriodVariant:
		return soap_out_ns2__StandardPeriodVariant(soap, tag, id, (const enum ns2__StandardPeriodVariant *)ptr, "ns2:StandardPeriodVariant");
	case SOAP_TYPE_ns2__StandardBeginningDateVariant:
		return soap_out_ns2__StandardBeginningDateVariant(soap, tag, id, (const enum ns2__StandardBeginningDateVariant *)ptr, "ns2:StandardBeginningDateVariant");
	case SOAP_TYPE_ns2__FillChecking:
		return soap_out_ns2__FillChecking(soap, tag, id, (const enum ns2__FillChecking *)ptr, "ns2:FillChecking");
	case SOAP_TYPE_ns2__FillCheckErrorStatus:
		return soap_out_ns2__FillCheckErrorStatus(soap, tag, id, (const enum ns2__FillCheckErrorStatus *)ptr, "ns2:FillCheckErrorStatus");
	case SOAP_TYPE_ns2__DateFractions:
		return soap_out_ns2__DateFractions(soap, tag, id, (const enum ns2__DateFractions *)ptr, "ns2:DateFractions");
	case SOAP_TYPE_ns2__AllowedSign:
		return soap_out_ns2__AllowedSign(soap, tag, id, (const enum ns2__AllowedSign *)ptr, "ns2:AllowedSign");
	case SOAP_TYPE_ns2__AllowedLength:
		return soap_out_ns2__AllowedLength(soap, tag, id, (const enum ns2__AllowedLength *)ptr, "ns2:AllowedLength");
	case SOAP_TYPE__ns2__Structure_Property:
		return ((_ns2__Structure_Property *)ptr)->soap_out(soap, "ns2:Structure-Property", id, NULL);
	case SOAP_TYPE__ns2__FixedStructure_Property:
		return ((_ns2__FixedStructure_Property *)ptr)->soap_out(soap, "ns2:FixedStructure-Property", id, NULL);
	case SOAP_TYPE_ns2__ValueStorage:
		return soap_out_ns2__ValueStorage(soap, tag, id, (const xsd__base64Binary *)ptr, "ns2:ValueStorage");
	case SOAP_TYPE_ns2__UUID:
		return soap_out_ns2__UUID(soap, tag, id, (const std::string *)ptr, "ns2:UUID");
	case SOAP_TYPE_ns2__Type:
		return soap_out_ns2__Type(soap, tag, id, (const std::string *)ptr, "ns2:Type");
	case SOAP_TYPE_ns2__Null:
		return soap_out_ns2__Null(soap, tag, id, (const std::string *)ptr, "ns2:Null");
	case SOAP_TYPE_ns2__CompositeID:
		return soap_out_ns2__CompositeID(soap, tag, id, (const std::string *)ptr, "ns2:CompositeID");
	case SOAP_TYPE_ns2__ValueTreeRow:
		return ((ns2__ValueTreeRow *)ptr)->soap_out(soap, tag, id, "ns2:ValueTreeRow");
	case SOAP_TYPE_ns2__ValueTreeColumn:
		return ((ns2__ValueTreeColumn *)ptr)->soap_out(soap, tag, id, "ns2:ValueTreeColumn");
	case SOAP_TYPE_ns2__ValueTree:
		return ((ns2__ValueTree *)ptr)->soap_out(soap, tag, id, "ns2:ValueTree");
	case SOAP_TYPE_ns2__ValueTableRow:
		return ((ns2__ValueTableRow *)ptr)->soap_out(soap, tag, id, "ns2:ValueTableRow");
	case SOAP_TYPE_ns2__ValueTableIndex:
		return ((ns2__ValueTableIndex *)ptr)->soap_out(soap, tag, id, "ns2:ValueTableIndex");
	case SOAP_TYPE_ns2__ValueTableColumn:
		return ((ns2__ValueTableColumn *)ptr)->soap_out(soap, tag, id, "ns2:ValueTableColumn");
	case SOAP_TYPE_ns2__ValueTable:
		return ((ns2__ValueTable *)ptr)->soap_out(soap, tag, id, "ns2:ValueTable");
	case SOAP_TYPE_ns2__ValueListType:
		return ((ns2__ValueListType *)ptr)->soap_out(soap, tag, id, "ns2:ValueListType");
	case SOAP_TYPE_ns2__ValueListItemType:
		return ((ns2__ValueListItemType *)ptr)->soap_out(soap, tag, id, "ns2:ValueListItemType");
	case SOAP_TYPE_ns2__TypeDescription:
		return ((ns2__TypeDescription *)ptr)->soap_out(soap, tag, id, "ns2:TypeDescription");
	case SOAP_TYPE_ns2__Structure:
		return ((ns2__Structure *)ptr)->soap_out(soap, tag, id, "ns2:Structure");
	case SOAP_TYPE_ns2__StringQualifiers:
		return ((ns2__StringQualifiers *)ptr)->soap_out(soap, tag, id, "ns2:StringQualifiers");
	case SOAP_TYPE_ns2__StandardPeriod:
		return ((ns2__StandardPeriod *)ptr)->soap_out(soap, tag, id, "ns2:StandardPeriod");
	case SOAP_TYPE_ns2__StandardBeginningDate:
		return ((ns2__StandardBeginningDate *)ptr)->soap_out(soap, tag, id, "ns2:StandardBeginningDate");
	case SOAP_TYPE_ns2__NumberQualifiers:
		return ((ns2__NumberQualifiers *)ptr)->soap_out(soap, tag, id, "ns2:NumberQualifiers");
	case SOAP_TYPE_ns2__Map:
		return ((ns2__Map *)ptr)->soap_out(soap, tag, id, "ns2:Map");
	case SOAP_TYPE_ns2__LocalStringType:
		return ((ns2__LocalStringType *)ptr)->soap_out(soap, tag, id, "ns2:LocalStringType");
	case SOAP_TYPE_ns2__LocalStringItemType:
		return ((ns2__LocalStringItemType *)ptr)->soap_out(soap, tag, id, "ns2:LocalStringItemType");
	case SOAP_TYPE_ns2__KeyAndValue:
		return ((ns2__KeyAndValue *)ptr)->soap_out(soap, tag, id, "ns2:KeyAndValue");
	case SOAP_TYPE_ns2__GenericException:
		return ((ns2__GenericException *)ptr)->soap_out(soap, tag, id, "ns2:GenericException");
	case SOAP_TYPE_ns2__FixedStructure:
		return ((ns2__FixedStructure *)ptr)->soap_out(soap, tag, id, "ns2:FixedStructure");
	case SOAP_TYPE_ns2__FixedMap:
		return ((ns2__FixedMap *)ptr)->soap_out(soap, tag, id, "ns2:FixedMap");
	case SOAP_TYPE_ns2__FixedArray:
		return ((ns2__FixedArray *)ptr)->soap_out(soap, tag, id, "ns2:FixedArray");
	case SOAP_TYPE_ns2__Exception:
		return ((ns2__Exception *)ptr)->soap_out(soap, tag, id, "ns2:Exception");
	case SOAP_TYPE_ns2__DateQualifiers:
		return ((ns2__DateQualifiers *)ptr)->soap_out(soap, tag, id, "ns2:DateQualifiers");
	case SOAP_TYPE_ns2__DataFillErrors:
		return ((ns2__DataFillErrors *)ptr)->soap_out(soap, tag, id, "ns2:DataFillErrors");
	case SOAP_TYPE_ns2__DataFillError:
		return ((ns2__DataFillError *)ptr)->soap_out(soap, tag, id, "ns2:DataFillError");
	case SOAP_TYPE_ns2__BinaryDataQualifiers:
		return ((ns2__BinaryDataQualifiers *)ptr)->soap_out(soap, tag, id, "ns2:BinaryDataQualifiers");
	case SOAP_TYPE_ns2__Array:
		return ((ns2__Array *)ptr)->soap_out(soap, tag, id, "ns2:Array");
	case SOAP_TYPE__ns1__QueryUniversalResponse:
		return ((_ns1__QueryUniversalResponse *)ptr)->soap_out(soap, "ns1:QueryUniversalResponse", id, NULL);
	case SOAP_TYPE__ns1__QueryUniversal:
		return ((_ns1__QueryUniversal *)ptr)->soap_out(soap, "ns1:QueryUniversal", id, NULL);
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		return ((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)ptr)->soap_out(soap, "ns1:ЗаписатьДанныеResponse", id, NULL);
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		return ((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)ptr)->soap_out(soap, "ns1:ЗаписатьДанные", id, NULL);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		return ((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)ptr)->soap_out(soap, "ns1:ЦеныНоменклатурыПоПериодамResponse", id, NULL);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		return ((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)ptr)->soap_out(soap, "ns1:ЦеныНоменклатурыПоПериодам", id, NULL);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		return ((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)ptr)->soap_out(soap, "ns1:ЦеныНоменклатурыПоГТДResponse", id, NULL);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		return ((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)ptr)->soap_out(soap, "ns1:ЦеныНоменклатурыПоГТД", id, NULL);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return ((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr)->soap_out(soap, "ns1:РасширенныйЗапросResponse", id, NULL);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return ((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr)->soap_out(soap, "ns1:РасширенныйЗапрос", id, NULL);
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return ((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr)->soap_out(soap, "ns1:УниверсальныйЗапросResponse", id, NULL);
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return ((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr)->soap_out(soap, "ns1:УниверсальныйЗапрос", id, NULL);
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		return ((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)ptr)->soap_out(soap, "ns1:ТоварыВПутиResponse", id, NULL);
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		return ((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)ptr)->soap_out(soap, "ns1:ТоварыВПути", id, NULL);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return ((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr)->soap_out(soap, "ns1:РасчитатьАномальныйСпросResponse", id, NULL);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return ((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr)->soap_out(soap, "ns1:РасчитатьАномальныйСпрос", id, NULL);
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		return ((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)ptr)->soap_out(soap, "ns1:ПродажиResponse", id, NULL);
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		return ((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)ptr)->soap_out(soap, "ns1:Продажи", id, NULL);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		return ((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)ptr)->soap_out(soap, "ns1:ПолучитьЦеныНоменклатурыResponse", id, NULL);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		return ((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)ptr)->soap_out(soap, "ns1:ПолучитьЦеныНоменклатуры", id, NULL);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		return ((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)ptr)->soap_out(soap, "ns1:ПолучитьКурсыВалютResponse", id, NULL);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		return ((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)ptr)->soap_out(soap, "ns1:ПолучитьКурсыВалют", id, NULL);
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		return ((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)ptr)->soap_out(soap, "ns1:ОстаткиResponse", id, NULL);
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		return ((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)ptr)->soap_out(soap, "ns1:Остатки", id, NULL);
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return ((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr)->soap_out(soap, "ns1:НеВыполненныйСпросResponse", id, NULL);
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return ((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr)->soap_out(soap, "ns1:НеВыполненныйСпрос", id, NULL);
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		return ((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)ptr)->soap_out(soap, "ns1:ИнформационныеБазыResponse", id, NULL);
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		return ((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)ptr)->soap_out(soap, "ns1:ИнформационныеБазы", id, NULL);
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		return ((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)ptr)->soap_out(soap, "ns1:ДниОтсутствияResponse", id, NULL);
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		return ((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)ptr)->soap_out(soap, "ns1:ДниОтсутствия", id, NULL);
	case SOAP_TYPE__ns1__GetStructureInfoResponse:
		return ((_ns1__GetStructureInfoResponse *)ptr)->soap_out(soap, "ns1:GetStructureInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetStructureInfo:
		return ((_ns1__GetStructureInfo *)ptr)->soap_out(soap, "ns1:GetStructureInfo", id, NULL);
	case SOAP_TYPE__ns1__GetAmountGoodsResponse:
		return ((_ns1__GetAmountGoodsResponse *)ptr)->soap_out(soap, "ns1:GetAmountGoodsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAmountGoods:
		return ((_ns1__GetAmountGoods *)ptr)->soap_out(soap, "ns1:GetAmountGoods", id, NULL);
	case SOAP_TYPE_ns1__Structure:
		return ((ns1__Structure *)ptr)->soap_out(soap, tag, id, "ns1:Structure");
	case SOAP_TYPE_ns1__Object:
		return ((ns1__Object *)ptr)->soap_out(soap, tag, id, "ns1:Object");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::wstring *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__QueryUniversalResponse:
		return soap_out_PointerTo_ns1__QueryUniversalResponse(soap, tag, id, (_ns1__QueryUniversalResponse *const*)ptr, "ns1:QueryUniversalResponse");
	case SOAP_TYPE_PointerTo_ns1__QueryUniversal:
		return soap_out_PointerTo_ns1__QueryUniversal(soap, tag, id, (_ns1__QueryUniversal *const*)ptr, "ns1:QueryUniversal");
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		return soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, id, (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *const*)ptr, "ns1:ЗаписатьДанныеResponse");
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		return soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, id, (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *const*)ptr, "ns1:ЗаписатьДанные");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		return soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, id, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *const*)ptr, "ns1:ЦеныНоменклатурыПоПериодамResponse");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		return soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, id, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *const*)ptr, "ns1:ЦеныНоменклатурыПоПериодам");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		return soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, id, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *const*)ptr, "ns1:ЦеныНоменклатурыПоГТДResponse");
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		return soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, id, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *const*)ptr, "ns1:ЦеныНоменклатурыПоГТД");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, id, (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*)ptr, "ns1:РасширенныйЗапросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, id, (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*)ptr, "ns1:РасширенныйЗапрос");
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, id, (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*)ptr, "ns1:УниверсальныйЗапросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, id, (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*)ptr, "ns1:УниверсальныйЗапрос");
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		return soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, id, (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *const*)ptr, "ns1:ТоварыВПутиResponse");
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		return soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, id, (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *const*)ptr, "ns1:ТоварыВПути");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, id, (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*)ptr, "ns1:РасчитатьАномальныйСпросResponse");
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, id, (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*)ptr, "ns1:РасчитатьАномальныйСпрос");
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		return soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, id, (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *const*)ptr, "ns1:ПродажиResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		return soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, id, (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *const*)ptr, "ns1:Продажи");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		return soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, id, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *const*)ptr, "ns1:ПолучитьЦеныНоменклатурыResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		return soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, id, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *const*)ptr, "ns1:ПолучитьЦеныНоменклатуры");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		return soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, id, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *const*)ptr, "ns1:ПолучитьКурсыВалютResponse");
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		return soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, id, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *const*)ptr, "ns1:ПолучитьКурсыВалют");
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		return soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, id, (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *const*)ptr, "ns1:ОстаткиResponse");
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		return soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, id, (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *const*)ptr, "ns1:Остатки");
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, id, (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*)ptr, "ns1:НеВыполненныйСпросResponse");
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, id, (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*)ptr, "ns1:НеВыполненныйСпрос");
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		return soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, id, (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *const*)ptr, "ns1:ИнформационныеБазыResponse");
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		return soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, id, (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *const*)ptr, "ns1:ИнформационныеБазы");
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		return soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, id, (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *const*)ptr, "ns1:ДниОтсутствияResponse");
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		return soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, id, (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *const*)ptr, "ns1:ДниОтсутствия");
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfoResponse:
		return soap_out_PointerTo_ns1__GetStructureInfoResponse(soap, tag, id, (_ns1__GetStructureInfoResponse *const*)ptr, "ns1:GetStructureInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfo:
		return soap_out_PointerTo_ns1__GetStructureInfo(soap, tag, id, (_ns1__GetStructureInfo *const*)ptr, "ns1:GetStructureInfo");
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoodsResponse:
		return soap_out_PointerTo_ns1__GetAmountGoodsResponse(soap, tag, id, (_ns1__GetAmountGoodsResponse *const*)ptr, "ns1:GetAmountGoodsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoods:
		return soap_out_PointerTo_ns1__GetAmountGoods(soap, tag, id, (_ns1__GetAmountGoods *const*)ptr, "ns1:GetAmountGoods");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons2__ValueTreeRow:
		return soap_out_PointerTons2__ValueTreeRow(soap, tag, id, (ns2__ValueTreeRow *const*)ptr, "ns2:ValueTreeRow");
	case SOAP_TYPE_PointerTons2__ValueTreeColumn:
		return soap_out_PointerTons2__ValueTreeColumn(soap, tag, id, (ns2__ValueTreeColumn *const*)ptr, "ns2:ValueTreeColumn");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_out_PointerToxsd__NMTOKEN(soap, tag, id, (std::wstring *const*)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons2__ValueTableRow:
		return soap_out_PointerTons2__ValueTableRow(soap, tag, id, (ns2__ValueTableRow *const*)ptr, "ns2:ValueTableRow");
	case SOAP_TYPE_PointerTons2__ValueTableIndex:
		return soap_out_PointerTons2__ValueTableIndex(soap, tag, id, (ns2__ValueTableIndex *const*)ptr, "ns2:ValueTableIndex");
	case SOAP_TYPE_PointerTons2__ValueTableColumn:
		return soap_out_PointerTons2__ValueTableColumn(soap, tag, id, (ns2__ValueTableColumn *const*)ptr, "ns2:ValueTableColumn");
	case SOAP_TYPE_PointerTons2__ValueListItemType:
		return soap_out_PointerTons2__ValueListItemType(soap, tag, id, (ns2__ValueListItemType *const*)ptr, "ns2:ValueListItemType");
	case SOAP_TYPE_PointerTons2__TypeDescription:
		return soap_out_PointerTons2__TypeDescription(soap, tag, id, (ns2__TypeDescription *const*)ptr, "ns2:TypeDescription");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__BinaryDataQualifiers:
		return soap_out_PointerTons2__BinaryDataQualifiers(soap, tag, id, (ns2__BinaryDataQualifiers *const*)ptr, "ns2:BinaryDataQualifiers");
	case SOAP_TYPE_PointerTons2__DateQualifiers:
		return soap_out_PointerTons2__DateQualifiers(soap, tag, id, (ns2__DateQualifiers *const*)ptr, "ns2:DateQualifiers");
	case SOAP_TYPE_PointerTons2__StringQualifiers:
		return soap_out_PointerTons2__StringQualifiers(soap, tag, id, (ns2__StringQualifiers *const*)ptr, "ns2:StringQualifiers");
	case SOAP_TYPE_PointerTons2__NumberQualifiers:
		return soap_out_PointerTons2__NumberQualifiers(soap, tag, id, (ns2__NumberQualifiers *const*)ptr, "ns2:NumberQualifiers");
	case SOAP_TYPE_PointerTons2__LocalStringItemType:
		return soap_out_PointerTons2__LocalStringItemType(soap, tag, id, (ns2__LocalStringItemType *const*)ptr, "ns2:LocalStringItemType");
	case SOAP_TYPE_PointerTons2__GenericException:
		return soap_out_PointerTons2__GenericException(soap, tag, id, (ns2__GenericException *const*)ptr, "ns2:GenericException");
	case SOAP_TYPE_PointerTons2__KeyAndValue:
		return soap_out_PointerTons2__KeyAndValue(soap, tag, id, (ns2__KeyAndValue *const*)ptr, "ns2:KeyAndValue");
	case SOAP_TYPE_PointerTons2__DataFillError:
		return soap_out_PointerTons2__DataFillError(soap, tag, id, (ns2__DataFillError *const*)ptr, "ns2:DataFillError");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__ValueTree:
		return soap_out_PointerTons2__ValueTree(soap, tag, id, (ns2__ValueTree *const*)ptr, "ns2:ValueTree");
	case SOAP_TYPE_PointerTons2__ValueListType:
		return soap_out_PointerTons2__ValueListType(soap, tag, id, (ns2__ValueListType *const*)ptr, "ns2:ValueListType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__ValueTable:
		return soap_out_PointerTons2__ValueTable(soap, tag, id, (ns2__ValueTable *const*)ptr, "ns2:ValueTable");
	case SOAP_TYPE_PointerTons2__Structure:
		return soap_out_PointerTons2__Structure(soap, tag, id, (ns2__Structure *const*)ptr, "ns2:Structure");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__Object:
		return soap_out_PointerTons1__Object(soap, tag, id, (ns1__Object *const*)ptr, "ns1:Object");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns2__Structure_Property:
		((_ns2__Structure_Property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__FixedStructure_Property:
		((_ns2__FixedStructure_Property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueStorage:
		soap_serialize_ns2__ValueStorage(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_ns2__UUID:
		soap_serialize_ns2__UUID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__Type:
		soap_serialize_ns2__Type(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__Null:
		soap_serialize_ns2__Null(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__CompositeID:
		soap_serialize_ns2__CompositeID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__ValueTreeRow:
		((ns2__ValueTreeRow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTreeColumn:
		((ns2__ValueTreeColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTree:
		((ns2__ValueTree *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTableRow:
		((ns2__ValueTableRow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTableIndex:
		((ns2__ValueTableIndex *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTableColumn:
		((ns2__ValueTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueTable:
		((ns2__ValueTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueListType:
		((ns2__ValueListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValueListItemType:
		((ns2__ValueListItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TypeDescription:
		((ns2__TypeDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Structure:
		((ns2__Structure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__StringQualifiers:
		((ns2__StringQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__StandardPeriod:
		((ns2__StandardPeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__StandardBeginningDate:
		((ns2__StandardBeginningDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NumberQualifiers:
		((ns2__NumberQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Map:
		((ns2__Map *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LocalStringType:
		((ns2__LocalStringType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LocalStringItemType:
		((ns2__LocalStringItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__KeyAndValue:
		((ns2__KeyAndValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GenericException:
		((ns2__GenericException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FixedStructure:
		((ns2__FixedStructure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FixedMap:
		((ns2__FixedMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FixedArray:
		((ns2__FixedArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Exception:
		((ns2__Exception *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DateQualifiers:
		((ns2__DateQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataFillErrors:
		((ns2__DataFillErrors *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DataFillError:
		((ns2__DataFillError *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BinaryDataQualifiers:
		((ns2__BinaryDataQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Array:
		((ns2__Array *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryUniversalResponse:
		((_ns1__QueryUniversalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryUniversal:
		((_ns1__QueryUniversal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStructureInfoResponse:
		((_ns1__GetStructureInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStructureInfo:
		((_ns1__GetStructureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAmountGoodsResponse:
		((_ns1__GetAmountGoodsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAmountGoods:
		((_ns1__GetAmountGoods *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Structure:
		((ns1__Structure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Object:
		((ns1__Object *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryUniversal_:
		soap_serialize___ns1__QueryUniversal_(soap, (const struct __ns1__QueryUniversal_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_:
		soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(soap, (const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response:
		soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(soap, (const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, (const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, (const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, (const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, (const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_:
		soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(soap, (const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response:
		soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(soap, (const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, (const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, (const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_:
		soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(soap, (const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response:
		soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(soap, (const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_:
		soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(soap, (const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response:
		soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(soap, (const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, (const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, (const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_:
		soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(soap, (const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response:
		soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(soap, (const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_:
		soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(soap, (const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *)ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response:
		soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(soap, (const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStructureInfo_:
		soap_serialize___ns1__GetStructureInfo_(soap, (const struct __ns1__GetStructureInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAmountGoods_:
		soap_serialize___ns1__GetAmountGoods_(soap, (const struct __ns1__GetAmountGoods_ *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryUniversal:
		soap_serialize___ns1__QueryUniversal(soap, (const struct __ns1__QueryUniversal *)ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, (const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, (const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, (const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, (const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, (const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, (const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, (const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, (const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, (const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, (const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, (const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, (const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, (const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, (const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, (const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, (const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, (const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, (const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, (const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, (const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, (const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, (const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStructureInfo:
		soap_serialize___ns1__GetStructureInfo(soap, (const struct __ns1__GetStructureInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAmountGoods:
		soap_serialize___ns1__GetAmountGoods(soap, (const struct __ns1__GetAmountGoods *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryUniversalResponse:
		soap_serialize_PointerTo_ns1__QueryUniversalResponse(soap, (_ns1__QueryUniversalResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryUniversal:
		soap_serialize_PointerTo_ns1__QueryUniversal(soap, (_ns1__QueryUniversal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfoResponse:
		soap_serialize_PointerTo_ns1__GetStructureInfoResponse(soap, (_ns1__GetStructureInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStructureInfo:
		soap_serialize_PointerTo_ns1__GetStructureInfo(soap, (_ns1__GetStructureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoodsResponse:
		soap_serialize_PointerTo_ns1__GetAmountGoodsResponse(soap, (_ns1__GetAmountGoodsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAmountGoods:
		soap_serialize_PointerTo_ns1__GetAmountGoods(soap, (_ns1__GetAmountGoods *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTreeRow:
		soap_serialize_PointerTons2__ValueTreeRow(soap, (ns2__ValueTreeRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTreeColumn:
		soap_serialize_PointerTons2__ValueTreeColumn(soap, (ns2__ValueTreeColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		soap_serialize_PointerToxsd__NMTOKEN(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTableRow:
		soap_serialize_PointerTons2__ValueTableRow(soap, (ns2__ValueTableRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTableIndex:
		soap_serialize_PointerTons2__ValueTableIndex(soap, (ns2__ValueTableIndex *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTableColumn:
		soap_serialize_PointerTons2__ValueTableColumn(soap, (ns2__ValueTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueListItemType:
		soap_serialize_PointerTons2__ValueListItemType(soap, (ns2__ValueListItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TypeDescription:
		soap_serialize_PointerTons2__TypeDescription(soap, (ns2__TypeDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BinaryDataQualifiers:
		soap_serialize_PointerTons2__BinaryDataQualifiers(soap, (ns2__BinaryDataQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DateQualifiers:
		soap_serialize_PointerTons2__DateQualifiers(soap, (ns2__DateQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StringQualifiers:
		soap_serialize_PointerTons2__StringQualifiers(soap, (ns2__StringQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NumberQualifiers:
		soap_serialize_PointerTons2__NumberQualifiers(soap, (ns2__NumberQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LocalStringItemType:
		soap_serialize_PointerTons2__LocalStringItemType(soap, (ns2__LocalStringItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GenericException:
		soap_serialize_PointerTons2__GenericException(soap, (ns2__GenericException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__KeyAndValue:
		soap_serialize_PointerTons2__KeyAndValue(soap, (ns2__KeyAndValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DataFillError:
		soap_serialize_PointerTons2__DataFillError(soap, (ns2__DataFillError *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTree:
		soap_serialize_PointerTons2__ValueTree(soap, (ns2__ValueTree *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueListType:
		soap_serialize_PointerTons2__ValueListType(soap, (ns2__ValueListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValueTable:
		soap_serialize_PointerTons2__ValueTable(soap, (ns2__ValueTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Structure:
		soap_serialize_PointerTons2__Structure(soap, (ns2__Structure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Object:
		soap_serialize_PointerTons1__Object(soap, (ns1__Object *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Object:
		return (void*)soap_instantiate_ns1__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Structure:
		return (void*)soap_instantiate_ns1__Structure(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAmountGoods:
		return (void*)soap_instantiate__ns1__GetAmountGoods(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAmountGoodsResponse:
		return (void*)soap_instantiate__ns1__GetAmountGoodsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStructureInfo:
		return (void*)soap_instantiate__ns1__GetStructureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStructureInfoResponse:
		return (void*)soap_instantiate__ns1__GetStructureInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		return (void*)soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		return (void*)soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		return (void*)soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		return (void*)soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		return (void*)soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		return (void*)soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		return (void*)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		return (void*)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		return (void*)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		return (void*)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		return (void*)soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		return (void*)soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		return (void*)soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		return (void*)soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		return (void*)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		return (void*)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		return (void*)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		return (void*)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		return (void*)soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		return (void*)soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryUniversal:
		return (void*)soap_instantiate__ns1__QueryUniversal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryUniversalResponse:
		return (void*)soap_instantiate__ns1__QueryUniversalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Array:
		return (void*)soap_instantiate_ns2__Array(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BinaryDataQualifiers:
		return (void*)soap_instantiate_ns2__BinaryDataQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataFillError:
		return (void*)soap_instantiate_ns2__DataFillError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DataFillErrors:
		return (void*)soap_instantiate_ns2__DataFillErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DateQualifiers:
		return (void*)soap_instantiate_ns2__DateQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FixedArray:
		return (void*)soap_instantiate_ns2__FixedArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FixedMap:
		return (void*)soap_instantiate_ns2__FixedMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__FixedStructure_Property:
		return (void*)soap_instantiate__ns2__FixedStructure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FixedStructure:
		return (void*)soap_instantiate_ns2__FixedStructure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GenericException:
		return (void*)soap_instantiate_ns2__GenericException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__KeyAndValue:
		return (void*)soap_instantiate_ns2__KeyAndValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LocalStringItemType:
		return (void*)soap_instantiate_ns2__LocalStringItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LocalStringType:
		return (void*)soap_instantiate_ns2__LocalStringType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Map:
		return (void*)soap_instantiate_ns2__Map(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NumberQualifiers:
		return (void*)soap_instantiate_ns2__NumberQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StandardBeginningDate:
		return (void*)soap_instantiate_ns2__StandardBeginningDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StandardPeriod:
		return (void*)soap_instantiate_ns2__StandardPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StringQualifiers:
		return (void*)soap_instantiate_ns2__StringQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__Structure_Property:
		return (void*)soap_instantiate__ns2__Structure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Structure:
		return (void*)soap_instantiate_ns2__Structure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TypeDescription:
		return (void*)soap_instantiate_ns2__TypeDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueListItemType:
		return (void*)soap_instantiate_ns2__ValueListItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueListType:
		return (void*)soap_instantiate_ns2__ValueListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTable:
		return (void*)soap_instantiate_ns2__ValueTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTableColumn:
		return (void*)soap_instantiate_ns2__ValueTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTableIndex:
		return (void*)soap_instantiate_ns2__ValueTableIndex(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTableRow:
		return (void*)soap_instantiate_ns2__ValueTableRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTree:
		return (void*)soap_instantiate_ns2__ValueTree(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTreeColumn:
		return (void*)soap_instantiate_ns2__ValueTreeColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueTreeRow:
		return (void*)soap_instantiate_ns2__ValueTreeRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Exception:
		return (void*)soap_instantiate_ns2__Exception(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAmountGoods:
		return (void*)soap_instantiate___ns1__GetAmountGoods(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStructureInfo:
		return (void*)soap_instantiate___ns1__GetStructureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		return (void*)soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		return (void*)soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		return (void*)soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		return (void*)soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		return (void*)soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		return (void*)soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		return (void*)soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		return (void*)soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		return (void*)soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		return (void*)soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		return (void*)soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		return (void*)soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryUniversal:
		return (void*)soap_instantiate___ns1__QueryUniversal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAmountGoods_:
		return (void*)soap_instantiate___ns1__GetAmountGoods_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStructureInfo_:
		return (void*)soap_instantiate___ns1__GetStructureInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response:
		return (void*)soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_:
		return (void*)soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response:
		return (void*)soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_:
		return (void*)soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		return (void*)soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		return (void*)soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response:
		return (void*)soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_:
		return (void*)soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_:
		return (void*)soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response:
		return (void*)soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_:
		return (void*)soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response:
		return (void*)soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_:
		return (void*)soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		return (void*)soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		return (void*)soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		return (void*)soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_:
		return (void*)soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response:
		return (void*)soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_:
		return (void*)soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryUniversal_:
		return (void*)soap_instantiate___ns1__QueryUniversal_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CompositeID:
		return (void*)soap_instantiate_ns2__CompositeID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Null:
		return (void*)soap_instantiate_ns2__Null(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Type:
		return (void*)soap_instantiate_ns2__Type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UUID:
		return (void*)soap_instantiate_ns2__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValueStorage:
		return (void*)soap_instantiate_ns2__ValueStorage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeRow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableRow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableIndex:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueListItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__UUID:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__Structure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocalStringItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__FixedStructure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__KeyAndValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataFillError:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DataFillError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		return (void*)soap_instantiate_std__vectorTemplateOfwstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Object:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Object(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Object:
		if (p->size < 0)
			SOAP_DELETE((ns1__Object*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Object*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Structure:
		if (p->size < 0)
			SOAP_DELETE((ns1__Structure*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Structure*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAmountGoods:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAmountGoods*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAmountGoods*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAmountGoodsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAmountGoodsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAmountGoodsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStructureInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStructureInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStructureInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetStructureInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetStructureInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetStructureInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p->ptr);
		break;
	case SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		if (p->size < 0)
			SOAP_DELETE((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p->ptr);
		break;
	case SOAP_TYPE__ns1__QueryUniversal:
		if (p->size < 0)
			SOAP_DELETE((_ns1__QueryUniversal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__QueryUniversal*)p->ptr);
		break;
	case SOAP_TYPE__ns1__QueryUniversalResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__QueryUniversalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__QueryUniversalResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Array:
		if (p->size < 0)
			SOAP_DELETE((ns2__Array*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Array*)p->ptr);
		break;
	case SOAP_TYPE_ns2__BinaryDataQualifiers:
		if (p->size < 0)
			SOAP_DELETE((ns2__BinaryDataQualifiers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__BinaryDataQualifiers*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataFillError:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataFillError*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataFillError*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DataFillErrors:
		if (p->size < 0)
			SOAP_DELETE((ns2__DataFillErrors*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DataFillErrors*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DateQualifiers:
		if (p->size < 0)
			SOAP_DELETE((ns2__DateQualifiers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DateQualifiers*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FixedArray:
		if (p->size < 0)
			SOAP_DELETE((ns2__FixedArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FixedArray*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FixedMap:
		if (p->size < 0)
			SOAP_DELETE((ns2__FixedMap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FixedMap*)p->ptr);
		break;
	case SOAP_TYPE__ns2__FixedStructure_Property:
		if (p->size < 0)
			SOAP_DELETE((_ns2__FixedStructure_Property*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__FixedStructure_Property*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FixedStructure:
		if (p->size < 0)
			SOAP_DELETE((ns2__FixedStructure*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FixedStructure*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GenericException:
		if (p->size < 0)
			SOAP_DELETE((ns2__GenericException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GenericException*)p->ptr);
		break;
	case SOAP_TYPE_ns2__KeyAndValue:
		if (p->size < 0)
			SOAP_DELETE((ns2__KeyAndValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__KeyAndValue*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LocalStringItemType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LocalStringItemType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LocalStringItemType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LocalStringType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LocalStringType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LocalStringType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Map:
		if (p->size < 0)
			SOAP_DELETE((ns2__Map*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Map*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NumberQualifiers:
		if (p->size < 0)
			SOAP_DELETE((ns2__NumberQualifiers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NumberQualifiers*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StandardBeginningDate:
		if (p->size < 0)
			SOAP_DELETE((ns2__StandardBeginningDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__StandardBeginningDate*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StandardPeriod:
		if (p->size < 0)
			SOAP_DELETE((ns2__StandardPeriod*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__StandardPeriod*)p->ptr);
		break;
	case SOAP_TYPE_ns2__StringQualifiers:
		if (p->size < 0)
			SOAP_DELETE((ns2__StringQualifiers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__StringQualifiers*)p->ptr);
		break;
	case SOAP_TYPE__ns2__Structure_Property:
		if (p->size < 0)
			SOAP_DELETE((_ns2__Structure_Property*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__Structure_Property*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Structure:
		if (p->size < 0)
			SOAP_DELETE((ns2__Structure*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Structure*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TypeDescription:
		if (p->size < 0)
			SOAP_DELETE((ns2__TypeDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TypeDescription*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueListItemType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueListItemType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueListItemType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTable:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTable*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTableColumn:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTableColumn*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTableColumn*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTableIndex:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTableIndex*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTableIndex*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTableRow:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTableRow*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTableRow*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTree:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTree*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTree*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTreeColumn:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTreeColumn*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTreeColumn*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueTreeRow:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValueTreeRow*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValueTreeRow*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Exception:
		if (p->size < 0)
			SOAP_DELETE((ns2__Exception*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Exception*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAmountGoods:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAmountGoods*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAmountGoods*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetStructureInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetStructureInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetStructureInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p->ptr);
		break;
	case SOAP_TYPE___ns1__QueryUniversal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__QueryUniversal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__QueryUniversal*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAmountGoods_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAmountGoods_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAmountGoods_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetStructureInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetStructureInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetStructureInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response*)p->ptr);
		break;
	case SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__QueryUniversal_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__QueryUniversal_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__QueryUniversal_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CompositeID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Null:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Type:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UUID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValueStorage:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeRow:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueTreeRow * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueTreeRow * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeColumn:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueTreeColumn * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueTreeColumn * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableRow:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueTableRow * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueTableRow * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableIndex:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueTableIndex * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueTableIndex * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableColumn:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueTableColumn * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueTableColumn * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueListItemType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ValueListItemType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ValueListItemType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__UUID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__Structure_Property >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__Structure_Property >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocalStringItemType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__LocalStringItemType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__LocalStringItemType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_ns2__FixedStructure_Property >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_ns2__FixedStructure_Property >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__KeyAndValue:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__KeyAndValue * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__KeyAndValue * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataFillError:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__DataFillError * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__DataFillError * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		if (p->size < 0)
			SOAP_DELETE((std::vector<wchar_t * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<wchar_t * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Object:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Object * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Object * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeRow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueTreeRow * >*)p)[len] = *(ns2__ValueTreeRow **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueTreeColumn * >*)p)[len] = *(ns2__ValueTreeColumn **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableRow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueTableRow * >*)p)[len] = *(ns2__ValueTableRow **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableIndex:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueTableIndex * >*)p)[len] = *(ns2__ValueTableIndex **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueTableColumn * >*)p)[len] = *(ns2__ValueTableColumn **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueListItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ValueListItemType * >*)p)[len] = *(ns2__ValueListItemType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__UUID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__Structure_Property >*)p)[len] = *(_ns2__Structure_Property *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocalStringItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__LocalStringItemType * >*)p)[len] = *(ns2__LocalStringItemType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_ns2__FixedStructure_Property >*)p)[len] = *(_ns2__FixedStructure_Property *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__KeyAndValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__KeyAndValue * >*)p)[len] = *(ns2__KeyAndValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataFillError:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__DataFillError * >*)p)[len] = *(ns2__DataFillError **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<wchar_t * >*)p)[len] = *(wchar_t **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Object:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Object * >*)p)[len] = *(ns1__Object **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StandardPeriodVariant(struct soap *soap, enum ns2__StandardPeriodVariant *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__StandardPeriodVariant
	*a = SOAP_DEFAULT_ns2__StandardPeriodVariant;
#else
	*a = (enum ns2__StandardPeriodVariant)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__StandardPeriodVariant[] =
{	{ (long)ns2__StandardPeriodVariant__Custom, "Custom" },
	{ (long)ns2__StandardPeriodVariant__Today, "Today" },
	{ (long)ns2__StandardPeriodVariant__ThisWeek, "ThisWeek" },
	{ (long)ns2__StandardPeriodVariant__ThisTenDays, "ThisTenDays" },
	{ (long)ns2__StandardPeriodVariant__ThisMonth, "ThisMonth" },
	{ (long)ns2__StandardPeriodVariant__ThisQuarter, "ThisQuarter" },
	{ (long)ns2__StandardPeriodVariant__ThisHalfYear, "ThisHalfYear" },
	{ (long)ns2__StandardPeriodVariant__ThisYear, "ThisYear" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisWeek, "FromBeginningOfThisWeek" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisTenDays, "FromBeginningOfThisTenDays" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisMonth, "FromBeginningOfThisMonth" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisQuarter, "FromBeginningOfThisQuarter" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisHalfYear, "FromBeginningOfThisHalfYear" },
	{ (long)ns2__StandardPeriodVariant__FromBeginningOfThisYear, "FromBeginningOfThisYear" },
	{ (long)ns2__StandardPeriodVariant__Yesterday, "Yesterday" },
	{ (long)ns2__StandardPeriodVariant__LastWeek, "LastWeek" },
	{ (long)ns2__StandardPeriodVariant__LastTenDays, "LastTenDays" },
	{ (long)ns2__StandardPeriodVariant__LastMonth, "LastMonth" },
	{ (long)ns2__StandardPeriodVariant__LastQuarter, "LastQuarter" },
	{ (long)ns2__StandardPeriodVariant__LastHalfYear, "LastHalfYear" },
	{ (long)ns2__StandardPeriodVariant__LastYear, "LastYear" },
	{ (long)ns2__StandardPeriodVariant__LastWeekTillSameWeekDay, "LastWeekTillSameWeekDay" },
	{ (long)ns2__StandardPeriodVariant__LastTenDaysTillSameDayNumber, "LastTenDaysTillSameDayNumber" },
	{ (long)ns2__StandardPeriodVariant__LastMonthTillSameDate, "LastMonthTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__LastQuarterTillSameDate, "LastQuarterTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__LastHalfYearTillSameDate, "LastHalfYearTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__LastYearTillSameDate, "LastYearTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__Tomorrow, "Tomorrow" },
	{ (long)ns2__StandardPeriodVariant__NextWeek, "NextWeek" },
	{ (long)ns2__StandardPeriodVariant__NextTenDays, "NextTenDays" },
	{ (long)ns2__StandardPeriodVariant__NextMonth, "NextMonth" },
	{ (long)ns2__StandardPeriodVariant__NextQuarter, "NextQuarter" },
	{ (long)ns2__StandardPeriodVariant__NextHalfYear, "NextHalfYear" },
	{ (long)ns2__StandardPeriodVariant__NextYear, "NextYear" },
	{ (long)ns2__StandardPeriodVariant__NextWeekTillSameWeekDay, "NextWeekTillSameWeekDay" },
	{ (long)ns2__StandardPeriodVariant__NextTenDaysTillSameDayNumber, "NextTenDaysTillSameDayNumber" },
	{ (long)ns2__StandardPeriodVariant__NextMonthTillSameDate, "NextMonthTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__NextQuarterTillSameDate, "NextQuarterTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__NextHalfYearTillSameDate, "NextHalfYearTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__NextYearTillSameDate, "NextYearTillSameDate" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisWeek, "TillEndOfThisWeek" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisTenDays, "TillEndOfThisTenDays" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisMonth, "TillEndOfThisMonth" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisQuarter, "TillEndOfThisQuarter" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisHalfYear, "TillEndOfThisHalfYear" },
	{ (long)ns2__StandardPeriodVariant__TillEndOfThisYear, "TillEndOfThisYear" },
	{ (long)ns2__StandardPeriodVariant__Last7Days, "Last7Days" },
	{ (long)ns2__StandardPeriodVariant__Next7Days, "Next7Days" },
	{ (long)ns2__StandardPeriodVariant__Month, "Month" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__StandardPeriodVariant2s(struct soap *soap, enum ns2__StandardPeriodVariant n)
{	const char *s = soap_code_str(soap_codes_ns2__StandardPeriodVariant, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StandardPeriodVariant(struct soap *soap, const char *tag, int id, const enum ns2__StandardPeriodVariant *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StandardPeriodVariant), type) || soap_send(soap, soap_ns2__StandardPeriodVariant2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__StandardPeriodVariant(struct soap *soap, const char *s, enum ns2__StandardPeriodVariant *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__StandardPeriodVariant, s);
	if (map)
		*a = (enum ns2__StandardPeriodVariant)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 48)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__StandardPeriodVariant)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__StandardPeriodVariant * SOAP_FMAC4 soap_in_ns2__StandardPeriodVariant(struct soap *soap, const char *tag, enum ns2__StandardPeriodVariant *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__StandardPeriodVariant *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StandardPeriodVariant, sizeof(enum ns2__StandardPeriodVariant), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__StandardPeriodVariant(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__StandardPeriodVariant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StandardPeriodVariant, 0, sizeof(enum ns2__StandardPeriodVariant), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StandardPeriodVariant(struct soap *soap, const enum ns2__StandardPeriodVariant *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StandardPeriodVariant);
	if (soap_out_ns2__StandardPeriodVariant(soap, tag?tag:"ns2:StandardPeriodVariant", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__StandardPeriodVariant * SOAP_FMAC4 soap_get_ns2__StandardPeriodVariant(struct soap *soap, enum ns2__StandardPeriodVariant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StandardPeriodVariant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StandardBeginningDateVariant(struct soap *soap, enum ns2__StandardBeginningDateVariant *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__StandardBeginningDateVariant
	*a = SOAP_DEFAULT_ns2__StandardBeginningDateVariant;
#else
	*a = (enum ns2__StandardBeginningDateVariant)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__StandardBeginningDateVariant[] =
{	{ (long)ns2__StandardBeginningDateVariant__Custom, "Custom" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisDay, "BeginningOfThisDay" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisWeek, "BeginningOfThisWeek" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisTenDays, "BeginningOfThisTenDays" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisMonth, "BeginningOfThisMonth" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisQuarter, "BeginningOfThisQuarter" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisHalfYear, "BeginningOfThisHalfYear" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfThisYear, "BeginningOfThisYear" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastDay, "BeginningOfLastDay" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastWeek, "BeginningOfLastWeek" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastTenDays, "BeginningOfLastTenDays" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastMonth, "BeginningOfLastMonth" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastQuarter, "BeginningOfLastQuarter" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastHalfYear, "BeginningOfLastHalfYear" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfLastYear, "BeginningOfLastYear" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextDay, "BeginningOfNextDay" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextWeek, "BeginningOfNextWeek" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextTenDays, "BeginningOfNextTenDays" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextMonth, "BeginningOfNextMonth" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextQuarter, "BeginningOfNextQuarter" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextHalfYear, "BeginningOfNextHalfYear" },
	{ (long)ns2__StandardBeginningDateVariant__BeginningOfNextYear, "BeginningOfNextYear" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__StandardBeginningDateVariant2s(struct soap *soap, enum ns2__StandardBeginningDateVariant n)
{	const char *s = soap_code_str(soap_codes_ns2__StandardBeginningDateVariant, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StandardBeginningDateVariant(struct soap *soap, const char *tag, int id, const enum ns2__StandardBeginningDateVariant *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StandardBeginningDateVariant), type) || soap_send(soap, soap_ns2__StandardBeginningDateVariant2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__StandardBeginningDateVariant(struct soap *soap, const char *s, enum ns2__StandardBeginningDateVariant *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__StandardBeginningDateVariant, s);
	if (map)
		*a = (enum ns2__StandardBeginningDateVariant)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 21)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__StandardBeginningDateVariant)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__StandardBeginningDateVariant * SOAP_FMAC4 soap_in_ns2__StandardBeginningDateVariant(struct soap *soap, const char *tag, enum ns2__StandardBeginningDateVariant *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__StandardBeginningDateVariant *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StandardBeginningDateVariant, sizeof(enum ns2__StandardBeginningDateVariant), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__StandardBeginningDateVariant(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__StandardBeginningDateVariant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StandardBeginningDateVariant, 0, sizeof(enum ns2__StandardBeginningDateVariant), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StandardBeginningDateVariant(struct soap *soap, const enum ns2__StandardBeginningDateVariant *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StandardBeginningDateVariant);
	if (soap_out_ns2__StandardBeginningDateVariant(soap, tag?tag:"ns2:StandardBeginningDateVariant", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__StandardBeginningDateVariant * SOAP_FMAC4 soap_get_ns2__StandardBeginningDateVariant(struct soap *soap, enum ns2__StandardBeginningDateVariant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StandardBeginningDateVariant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FillChecking(struct soap *soap, enum ns2__FillChecking *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__FillChecking
	*a = SOAP_DEFAULT_ns2__FillChecking;
#else
	*a = (enum ns2__FillChecking)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__FillChecking[] =
{	{ (long)ns2__FillChecking__DontCheck, "DontCheck" },
	{ (long)ns2__FillChecking__ShowError, "ShowError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__FillChecking2s(struct soap *soap, enum ns2__FillChecking n)
{	const char *s = soap_code_str(soap_codes_ns2__FillChecking, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillChecking(struct soap *soap, const char *tag, int id, const enum ns2__FillChecking *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillChecking), type) || soap_send(soap, soap_ns2__FillChecking2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__FillChecking(struct soap *soap, const char *s, enum ns2__FillChecking *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__FillChecking, s);
	if (map)
		*a = (enum ns2__FillChecking)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__FillChecking)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__FillChecking * SOAP_FMAC4 soap_in_ns2__FillChecking(struct soap *soap, const char *tag, enum ns2__FillChecking *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__FillChecking *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillChecking, sizeof(enum ns2__FillChecking), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__FillChecking(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__FillChecking *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillChecking, 0, sizeof(enum ns2__FillChecking), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FillChecking(struct soap *soap, const enum ns2__FillChecking *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FillChecking);
	if (soap_out_ns2__FillChecking(soap, tag?tag:"ns2:FillChecking", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__FillChecking * SOAP_FMAC4 soap_get_ns2__FillChecking(struct soap *soap, enum ns2__FillChecking *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillChecking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FillCheckErrorStatus(struct soap *soap, enum ns2__FillCheckErrorStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__FillCheckErrorStatus
	*a = SOAP_DEFAULT_ns2__FillCheckErrorStatus;
#else
	*a = (enum ns2__FillCheckErrorStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__FillCheckErrorStatus[] =
{	{ (long)ns2__FillCheckErrorStatus__Error, "Error" },
	{ (long)ns2__FillCheckErrorStatus__Warning, "Warning" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__FillCheckErrorStatus2s(struct soap *soap, enum ns2__FillCheckErrorStatus n)
{	const char *s = soap_code_str(soap_codes_ns2__FillCheckErrorStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillCheckErrorStatus(struct soap *soap, const char *tag, int id, const enum ns2__FillCheckErrorStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillCheckErrorStatus), type) || soap_send(soap, soap_ns2__FillCheckErrorStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__FillCheckErrorStatus(struct soap *soap, const char *s, enum ns2__FillCheckErrorStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__FillCheckErrorStatus, s);
	if (map)
		*a = (enum ns2__FillCheckErrorStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__FillCheckErrorStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__FillCheckErrorStatus * SOAP_FMAC4 soap_in_ns2__FillCheckErrorStatus(struct soap *soap, const char *tag, enum ns2__FillCheckErrorStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__FillCheckErrorStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillCheckErrorStatus, sizeof(enum ns2__FillCheckErrorStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__FillCheckErrorStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__FillCheckErrorStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillCheckErrorStatus, 0, sizeof(enum ns2__FillCheckErrorStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FillCheckErrorStatus(struct soap *soap, const enum ns2__FillCheckErrorStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FillCheckErrorStatus);
	if (soap_out_ns2__FillCheckErrorStatus(soap, tag?tag:"ns2:FillCheckErrorStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__FillCheckErrorStatus * SOAP_FMAC4 soap_get_ns2__FillCheckErrorStatus(struct soap *soap, enum ns2__FillCheckErrorStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillCheckErrorStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DateFractions(struct soap *soap, enum ns2__DateFractions *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DateFractions
	*a = SOAP_DEFAULT_ns2__DateFractions;
#else
	*a = (enum ns2__DateFractions)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DateFractions[] =
{	{ (long)ns2__DateFractions__Date, "Date" },
	{ (long)ns2__DateFractions__Time, "Time" },
	{ (long)ns2__DateFractions__DateTime, "DateTime" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DateFractions2s(struct soap *soap, enum ns2__DateFractions n)
{	const char *s = soap_code_str(soap_codes_ns2__DateFractions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DateFractions(struct soap *soap, const char *tag, int id, const enum ns2__DateFractions *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DateFractions), type) || soap_send(soap, soap_ns2__DateFractions2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DateFractions(struct soap *soap, const char *s, enum ns2__DateFractions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DateFractions, s);
	if (map)
		*a = (enum ns2__DateFractions)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DateFractions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DateFractions * SOAP_FMAC4 soap_in_ns2__DateFractions(struct soap *soap, const char *tag, enum ns2__DateFractions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DateFractions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DateFractions, sizeof(enum ns2__DateFractions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DateFractions(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DateFractions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DateFractions, 0, sizeof(enum ns2__DateFractions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DateFractions(struct soap *soap, const enum ns2__DateFractions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DateFractions);
	if (soap_out_ns2__DateFractions(soap, tag?tag:"ns2:DateFractions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DateFractions * SOAP_FMAC4 soap_get_ns2__DateFractions(struct soap *soap, enum ns2__DateFractions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DateFractions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AllowedSign(struct soap *soap, enum ns2__AllowedSign *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AllowedSign
	*a = SOAP_DEFAULT_ns2__AllowedSign;
#else
	*a = (enum ns2__AllowedSign)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AllowedSign[] =
{	{ (long)ns2__AllowedSign__Any, "Any" },
	{ (long)ns2__AllowedSign__Nonnegative, "Nonnegative" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AllowedSign2s(struct soap *soap, enum ns2__AllowedSign n)
{	const char *s = soap_code_str(soap_codes_ns2__AllowedSign, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AllowedSign(struct soap *soap, const char *tag, int id, const enum ns2__AllowedSign *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AllowedSign), type) || soap_send(soap, soap_ns2__AllowedSign2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AllowedSign(struct soap *soap, const char *s, enum ns2__AllowedSign *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AllowedSign, s);
	if (map)
		*a = (enum ns2__AllowedSign)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AllowedSign)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AllowedSign * SOAP_FMAC4 soap_in_ns2__AllowedSign(struct soap *soap, const char *tag, enum ns2__AllowedSign *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AllowedSign *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AllowedSign, sizeof(enum ns2__AllowedSign), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AllowedSign(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AllowedSign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AllowedSign, 0, sizeof(enum ns2__AllowedSign), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AllowedSign(struct soap *soap, const enum ns2__AllowedSign *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AllowedSign);
	if (soap_out_ns2__AllowedSign(soap, tag?tag:"ns2:AllowedSign", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AllowedSign * SOAP_FMAC4 soap_get_ns2__AllowedSign(struct soap *soap, enum ns2__AllowedSign *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AllowedSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AllowedLength(struct soap *soap, enum ns2__AllowedLength *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AllowedLength
	*a = SOAP_DEFAULT_ns2__AllowedLength;
#else
	*a = (enum ns2__AllowedLength)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AllowedLength[] =
{	{ (long)ns2__AllowedLength__Fixed, "Fixed" },
	{ (long)ns2__AllowedLength__Variable, "Variable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AllowedLength2s(struct soap *soap, enum ns2__AllowedLength n)
{	const char *s = soap_code_str(soap_codes_ns2__AllowedLength, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AllowedLength(struct soap *soap, const char *tag, int id, const enum ns2__AllowedLength *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AllowedLength), type) || soap_send(soap, soap_ns2__AllowedLength2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AllowedLength(struct soap *soap, const char *s, enum ns2__AllowedLength *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AllowedLength, s);
	if (map)
		*a = (enum ns2__AllowedLength)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AllowedLength)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AllowedLength * SOAP_FMAC4 soap_in_ns2__AllowedLength(struct soap *soap, const char *tag, enum ns2__AllowedLength *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AllowedLength *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AllowedLength, sizeof(enum ns2__AllowedLength), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AllowedLength(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AllowedLength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AllowedLength, 0, sizeof(enum ns2__AllowedLength), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AllowedLength(struct soap *soap, const enum ns2__AllowedLength *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AllowedLength);
	if (soap_out_ns2__AllowedLength(soap, tag?tag:"ns2:AllowedLength", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AllowedLength * SOAP_FMAC4 soap_get_ns2__AllowedLength(struct soap *soap, enum ns2__AllowedLength *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AllowedLength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__Structure_Property::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns2__Structure_Property::Value = NULL;
	soap_default_xsd__NMTOKEN(soap, &this->_ns2__Structure_Property::name);
}

void _ns2__Structure_Property::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _ns2__Structure_Property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__Structure_Property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__Structure_Property(struct soap *soap, const char *tag, int id, const _ns2__Structure_Property *a, const char *type)
{
	soap_set_attr(soap, "name", soap_wchar2s(soap, ((_ns2__Structure_Property*)a)->name.c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__Structure_Property), type))
		return soap->error;
	soap_outliteral(soap, "ns2:Value", &(a->_ns2__Structure_Property::Value), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns2__Structure_Property::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__Structure_Property(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__Structure_Property * SOAP_FMAC4 soap_in__ns2__Structure_Property(struct soap *soap, const char *tag, _ns2__Structure_Property *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__Structure_Property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__Structure_Property, sizeof(_ns2__Structure_Property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__Structure_Property)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__Structure_Property *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((_ns2__Structure_Property*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Value", &(a->_ns2__Structure_Property::Value)))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__Structure_Property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__Structure_Property, 0, sizeof(_ns2__Structure_Property), 0, soap_copy__ns2__Structure_Property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__Structure_Property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__Structure_Property);
	if (this->soap_out(soap, tag?tag:"ns2:Structure-Property", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__Structure_Property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__Structure_Property(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__Structure_Property * SOAP_FMAC4 soap_get__ns2__Structure_Property(struct soap *soap, _ns2__Structure_Property *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__Structure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__Structure_Property * SOAP_FMAC2 soap_instantiate__ns2__Structure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__Structure_Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__Structure_Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__Structure_Property);
		if (size)
			*size = sizeof(_ns2__Structure_Property);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__Structure_Property, n);
		if (size)
			*size = n * sizeof(_ns2__Structure_Property);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__Structure_Property*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__Structure_Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__Structure_Property %p -> %p\n", q, p));
	*(_ns2__Structure_Property*)p = *(_ns2__Structure_Property*)q;
}

void _ns2__FixedStructure_Property::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns2__FixedStructure_Property::Value = NULL;
	soap_default_xsd__NMTOKEN(soap, &this->_ns2__FixedStructure_Property::name);
}

void _ns2__FixedStructure_Property::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _ns2__FixedStructure_Property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__FixedStructure_Property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__FixedStructure_Property(struct soap *soap, const char *tag, int id, const _ns2__FixedStructure_Property *a, const char *type)
{
	soap_set_attr(soap, "name", soap_wchar2s(soap, ((_ns2__FixedStructure_Property*)a)->name.c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__FixedStructure_Property), type))
		return soap->error;
	soap_outliteral(soap, "ns2:Value", &(a->_ns2__FixedStructure_Property::Value), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns2__FixedStructure_Property::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__FixedStructure_Property(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__FixedStructure_Property * SOAP_FMAC4 soap_in__ns2__FixedStructure_Property(struct soap *soap, const char *tag, _ns2__FixedStructure_Property *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__FixedStructure_Property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__FixedStructure_Property, sizeof(_ns2__FixedStructure_Property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__FixedStructure_Property)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__FixedStructure_Property *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((_ns2__FixedStructure_Property*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Value", &(a->_ns2__FixedStructure_Property::Value)))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__FixedStructure_Property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__FixedStructure_Property, 0, sizeof(_ns2__FixedStructure_Property), 0, soap_copy__ns2__FixedStructure_Property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__FixedStructure_Property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__FixedStructure_Property);
	if (this->soap_out(soap, tag?tag:"ns2:FixedStructure-Property", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__FixedStructure_Property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__FixedStructure_Property(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__FixedStructure_Property * SOAP_FMAC4 soap_get__ns2__FixedStructure_Property(struct soap *soap, _ns2__FixedStructure_Property *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__FixedStructure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__FixedStructure_Property * SOAP_FMAC2 soap_instantiate__ns2__FixedStructure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__FixedStructure_Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__FixedStructure_Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__FixedStructure_Property);
		if (size)
			*size = sizeof(_ns2__FixedStructure_Property);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__FixedStructure_Property, n);
		if (size)
			*size = n * sizeof(_ns2__FixedStructure_Property);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__FixedStructure_Property*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__FixedStructure_Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__FixedStructure_Property %p -> %p\n", q, p));
	*(_ns2__FixedStructure_Property*)p = *(_ns2__FixedStructure_Property*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueStorage(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_ns2__ValueStorage);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns2__ValueStorage);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_ns2__ValueStorage(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueStorage, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueStorage, 0, sizeof(xsd__base64Binary), 0, soap_copy_ns2__ValueStorage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ValueStorage(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns2__ValueStorage);
	if (soap_out_ns2__ValueStorage(soap, tag?tag:"ns2:ValueStorage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns2__ValueStorage(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueStorage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UUID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UUID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__UUID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__UUID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__UUID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__UUID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__UUID, 0, sizeof(std::string), 0, soap_copy_ns2__UUID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UUID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UUID);
	if (soap_out_ns2__UUID(soap, tag?tag:"ns2:UUID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__UUID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UUID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Type(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Type(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__Type), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__Type(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__Type, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__Type, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__Type, 0, sizeof(std::string), 0, soap_copy_ns2__Type);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Type(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Type);
	if (soap_out_ns2__Type(soap, tag?tag:"ns2:Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__Type(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Null(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Null(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__Null), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__Null(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__Null, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__Null, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__Null, 0, sizeof(std::string), 0, soap_copy_ns2__Null);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Null(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Null);
	if (soap_out_ns2__Null(soap, tag?tag:"ns2:Null", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__Null(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Null(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CompositeID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CompositeID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__CompositeID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__CompositeID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__CompositeID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__CompositeID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__CompositeID, 0, sizeof(std::string), 0, soap_copy_ns2__CompositeID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CompositeID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CompositeID);
	if (soap_out_ns2__CompositeID(soap, tag?tag:"ns2:CompositeID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__CompositeID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CompositeID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ValueTreeRow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, &this->ns2__ValueTreeRow::row);
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__ValueTreeRow::Value);
	/* transient soap skipped */
}

void ns2__ValueTreeRow::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, &this->ns2__ValueTreeRow::row);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__ValueTreeRow::Value);
	/* transient soap skipped */
#endif
}

int ns2__ValueTreeRow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTreeRow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTreeRow(struct soap *soap, const char *tag, int id, const ns2__ValueTreeRow *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTreeRow), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, "ns2:row", -1, &(a->ns2__ValueTreeRow::row), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns2:Value", -1, &(a->ns2__ValueTreeRow::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTreeRow::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTreeRow(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTreeRow * SOAP_FMAC4 soap_in_ns2__ValueTreeRow(struct soap *soap, const char *tag, ns2__ValueTreeRow *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTreeRow *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTreeRow, sizeof(ns2__ValueTreeRow), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTreeRow)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTreeRow *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, "ns2:row", &(a->ns2__ValueTreeRow::row), "ns2:ValueTreeRow"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "ns2:Value", &(a->ns2__ValueTreeRow::Value), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTreeRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTreeRow, 0, sizeof(ns2__ValueTreeRow), 0, soap_copy_ns2__ValueTreeRow);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTreeRow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTreeRow);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTreeRow", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTreeRow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTreeRow(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTreeRow * SOAP_FMAC4 soap_get_ns2__ValueTreeRow(struct soap *soap, ns2__ValueTreeRow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTreeRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTreeRow * SOAP_FMAC2 soap_instantiate_ns2__ValueTreeRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTreeRow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTreeRow, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTreeRow);
		if (size)
			*size = sizeof(ns2__ValueTreeRow);
		((ns2__ValueTreeRow*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTreeRow, n);
		if (size)
			*size = n * sizeof(ns2__ValueTreeRow);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTreeRow*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTreeRow*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTreeRow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTreeRow %p -> %p\n", q, p));
	*(ns2__ValueTreeRow*)p = *(ns2__ValueTreeRow*)q;
}

void ns2__ValueTreeColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ValueTreeColumn::Name = NULL;
	this->ns2__ValueTreeColumn::ValueType = NULL;
	this->ns2__ValueTreeColumn::Title = NULL;
	this->ns2__ValueTreeColumn::Width = NULL;
	/* transient soap skipped */
}

void ns2__ValueTreeColumn::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__NMTOKEN(soap, &this->ns2__ValueTreeColumn::Name);
	soap_serialize_PointerTons2__TypeDescription(soap, &this->ns2__ValueTreeColumn::ValueType);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ValueTreeColumn::Title);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->ns2__ValueTreeColumn::Width);
	/* transient soap skipped */
#endif
}

int ns2__ValueTreeColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTreeColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTreeColumn(struct soap *soap, const char *tag, int id, const ns2__ValueTreeColumn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTreeColumn), type))
		return soap->error;
	if (soap_out_PointerToxsd__NMTOKEN(soap, "ns2:Name", -1, &(a->ns2__ValueTreeColumn::Name), ""))
		return soap->error;
	if (soap_out_PointerTons2__TypeDescription(soap, "ns2:ValueType", -1, &(a->ns2__ValueTreeColumn::ValueType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Title", -1, &(a->ns2__ValueTreeColumn::Title), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "ns2:Width", -1, &(a->ns2__ValueTreeColumn::Width), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTreeColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTreeColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTreeColumn * SOAP_FMAC4 soap_in_ns2__ValueTreeColumn(struct soap *soap, const char *tag, ns2__ValueTreeColumn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTreeColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTreeColumn, sizeof(ns2__ValueTreeColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTreeColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTreeColumn *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_ValueType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NMTOKEN(soap, "ns2:Name", &(a->ns2__ValueTreeColumn::Name), "xsd:NMTOKEN"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_ValueType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TypeDescription(soap, "ns2:ValueType", &(a->ns2__ValueTreeColumn::ValueType), "ns2:TypeDescription"))
				{	soap_flag_ValueType1--;
					continue;
				}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Title", &(a->ns2__ValueTreeColumn::Title), "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			if (soap_flag_Width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "ns2:Width", &(a->ns2__ValueTreeColumn::Width), "xsd:nonNegativeInteger"))
				{	soap_flag_Width1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTreeColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTreeColumn, 0, sizeof(ns2__ValueTreeColumn), 0, soap_copy_ns2__ValueTreeColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTreeColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTreeColumn);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTreeColumn", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTreeColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTreeColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTreeColumn * SOAP_FMAC4 soap_get_ns2__ValueTreeColumn(struct soap *soap, ns2__ValueTreeColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTreeColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTreeColumn * SOAP_FMAC2 soap_instantiate_ns2__ValueTreeColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTreeColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTreeColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTreeColumn);
		if (size)
			*size = sizeof(ns2__ValueTreeColumn);
		((ns2__ValueTreeColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTreeColumn, n);
		if (size)
			*size = n * sizeof(ns2__ValueTreeColumn);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTreeColumn*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTreeColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTreeColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTreeColumn %p -> %p\n", q, p));
	*(ns2__ValueTreeColumn*)p = *(ns2__ValueTreeColumn*)q;
}

void ns2__ValueTree::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, &this->ns2__ValueTree::column);
	soap_default_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, &this->ns2__ValueTree::row);
	/* transient soap skipped */
}

void ns2__ValueTree::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, &this->ns2__ValueTree::column);
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, &this->ns2__ValueTree::row);
	/* transient soap skipped */
#endif
}

int ns2__ValueTree::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTree(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTree(struct soap *soap, const char *tag, int id, const ns2__ValueTree *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTree), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, "ns2:column", -1, &(a->ns2__ValueTree::column), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, "ns2:row", -1, &(a->ns2__ValueTree::row), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTree::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTree(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTree * SOAP_FMAC4 soap_in_ns2__ValueTree(struct soap *soap, const char *tag, ns2__ValueTree *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTree *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTree, sizeof(ns2__ValueTree), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTree)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTree *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, "ns2:column", &(a->ns2__ValueTree::column), "ns2:ValueTreeColumn"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, "ns2:row", &(a->ns2__ValueTree::row), "ns2:ValueTreeRow"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTree, 0, sizeof(ns2__ValueTree), 0, soap_copy_ns2__ValueTree);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTree::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTree);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTree", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTree::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTree(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTree * SOAP_FMAC4 soap_get_ns2__ValueTree(struct soap *soap, ns2__ValueTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTree * SOAP_FMAC2 soap_instantiate_ns2__ValueTree(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTree(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTree, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTree);
		if (size)
			*size = sizeof(ns2__ValueTree);
		((ns2__ValueTree*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTree, n);
		if (size)
			*size = n * sizeof(ns2__ValueTree);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTree*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTree*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTree(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTree %p -> %p\n", q, p));
	*(ns2__ValueTree*)p = *(ns2__ValueTree*)q;
}

void ns2__ValueTableRow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__ValueTableRow::Value);
	/* transient soap skipped */
}

void ns2__ValueTableRow::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__ValueTableRow::Value);
	/* transient soap skipped */
#endif
}

int ns2__ValueTableRow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTableRow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTableRow(struct soap *soap, const char *tag, int id, const ns2__ValueTableRow *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTableRow), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:Value", -1, &(a->ns2__ValueTableRow::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTableRow::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTableRow(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTableRow * SOAP_FMAC4 soap_in_ns2__ValueTableRow(struct soap *soap, const char *tag, ns2__ValueTableRow *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTableRow *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTableRow, sizeof(ns2__ValueTableRow), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTableRow)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTableRow *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:Value", &(a->ns2__ValueTableRow::Value), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTableRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTableRow, 0, sizeof(ns2__ValueTableRow), 0, soap_copy_ns2__ValueTableRow);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTableRow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTableRow);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTableRow", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTableRow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTableRow(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTableRow * SOAP_FMAC4 soap_get_ns2__ValueTableRow(struct soap *soap, ns2__ValueTableRow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTableRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTableRow * SOAP_FMAC2 soap_instantiate_ns2__ValueTableRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTableRow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTableRow, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTableRow);
		if (size)
			*size = sizeof(ns2__ValueTableRow);
		((ns2__ValueTableRow*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTableRow, n);
		if (size)
			*size = n * sizeof(ns2__ValueTableRow);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTableRow*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTableRow*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTableRow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTableRow %p -> %p\n", q, p));
	*(ns2__ValueTableRow*)p = *(ns2__ValueTableRow*)q;
}

void ns2__ValueTableIndex::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__NMTOKEN(soap, &this->ns2__ValueTableIndex::column);
	/* transient soap skipped */
}

void ns2__ValueTableIndex::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__NMTOKEN(soap, &this->ns2__ValueTableIndex::column);
	/* transient soap skipped */
#endif
}

int ns2__ValueTableIndex::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTableIndex(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTableIndex(struct soap *soap, const char *tag, int id, const ns2__ValueTableIndex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTableIndex), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__NMTOKEN(soap, "ns2:column", -1, &(a->ns2__ValueTableIndex::column), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTableIndex::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTableIndex(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTableIndex * SOAP_FMAC4 soap_in_ns2__ValueTableIndex(struct soap *soap, const char *tag, ns2__ValueTableIndex *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTableIndex *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTableIndex, sizeof(ns2__ValueTableIndex), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTableIndex)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTableIndex *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__NMTOKEN(soap, "ns2:column", &(a->ns2__ValueTableIndex::column), "xsd:NMTOKEN"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTableIndex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTableIndex, 0, sizeof(ns2__ValueTableIndex), 0, soap_copy_ns2__ValueTableIndex);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ValueTableIndex::column.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ValueTableIndex::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTableIndex);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTableIndex", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTableIndex::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTableIndex(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTableIndex * SOAP_FMAC4 soap_get_ns2__ValueTableIndex(struct soap *soap, ns2__ValueTableIndex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTableIndex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTableIndex * SOAP_FMAC2 soap_instantiate_ns2__ValueTableIndex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTableIndex(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTableIndex, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTableIndex);
		if (size)
			*size = sizeof(ns2__ValueTableIndex);
		((ns2__ValueTableIndex*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTableIndex, n);
		if (size)
			*size = n * sizeof(ns2__ValueTableIndex);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTableIndex*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTableIndex*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTableIndex(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTableIndex %p -> %p\n", q, p));
	*(ns2__ValueTableIndex*)p = *(ns2__ValueTableIndex*)q;
}

void ns2__ValueTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ValueTableColumn::Name = NULL;
	this->ns2__ValueTableColumn::ValueType = NULL;
	this->ns2__ValueTableColumn::Title = NULL;
	this->ns2__ValueTableColumn::Width = NULL;
	/* transient soap skipped */
}

void ns2__ValueTableColumn::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__NMTOKEN(soap, &this->ns2__ValueTableColumn::Name);
	soap_serialize_PointerTons2__TypeDescription(soap, &this->ns2__ValueTableColumn::ValueType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns2__ValueTableColumn::Title);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->ns2__ValueTableColumn::Width);
	/* transient soap skipped */
#endif
}

int ns2__ValueTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTableColumn(struct soap *soap, const char *tag, int id, const ns2__ValueTableColumn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTableColumn), type))
		return soap->error;
	if (soap_out_PointerToxsd__NMTOKEN(soap, "ns2:Name", -1, &(a->ns2__ValueTableColumn::Name), ""))
		return soap->error;
	if (soap_out_PointerTons2__TypeDescription(soap, "ns2:ValueType", -1, &(a->ns2__ValueTableColumn::ValueType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns2:Title", -1, &(a->ns2__ValueTableColumn::Title), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "ns2:Width", -1, &(a->ns2__ValueTableColumn::Width), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTableColumn * SOAP_FMAC4 soap_in_ns2__ValueTableColumn(struct soap *soap, const char *tag, ns2__ValueTableColumn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTableColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTableColumn, sizeof(ns2__ValueTableColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTableColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTableColumn *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_ValueType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NMTOKEN(soap, "ns2:Name", &(a->ns2__ValueTableColumn::Name), "xsd:NMTOKEN"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_ValueType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TypeDescription(soap, "ns2:ValueType", &(a->ns2__ValueTableColumn::ValueType), "ns2:TypeDescription"))
				{	soap_flag_ValueType1--;
					continue;
				}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns2:Title", &(a->ns2__ValueTableColumn::Title), "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			if (soap_flag_Width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "ns2:Width", &(a->ns2__ValueTableColumn::Width), "xsd:nonNegativeInteger"))
				{	soap_flag_Width1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTableColumn, 0, sizeof(ns2__ValueTableColumn), 0, soap_copy_ns2__ValueTableColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTableColumn);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTableColumn", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTableColumn * SOAP_FMAC4 soap_get_ns2__ValueTableColumn(struct soap *soap, ns2__ValueTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTableColumn * SOAP_FMAC2 soap_instantiate_ns2__ValueTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTableColumn);
		if (size)
			*size = sizeof(ns2__ValueTableColumn);
		((ns2__ValueTableColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTableColumn, n);
		if (size)
			*size = n * sizeof(ns2__ValueTableColumn);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTableColumn*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTableColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTableColumn %p -> %p\n", q, p));
	*(ns2__ValueTableColumn*)p = *(ns2__ValueTableColumn*)q;
}

void ns2__ValueTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, &this->ns2__ValueTable::column);
	soap_default_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, &this->ns2__ValueTable::index);
	soap_default_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, &this->ns2__ValueTable::row);
	/* transient soap skipped */
}

void ns2__ValueTable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, &this->ns2__ValueTable::column);
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, &this->ns2__ValueTable::index);
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, &this->ns2__ValueTable::row);
	/* transient soap skipped */
#endif
}

int ns2__ValueTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueTable(struct soap *soap, const char *tag, int id, const ns2__ValueTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueTable), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, "ns2:column", -1, &(a->ns2__ValueTable::column), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, "ns2:index", -1, &(a->ns2__ValueTable::index), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, "ns2:row", -1, &(a->ns2__ValueTable::row), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueTable(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueTable * SOAP_FMAC4 soap_in_ns2__ValueTable(struct soap *soap, const char *tag, ns2__ValueTable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueTable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueTable, sizeof(ns2__ValueTable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueTable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueTable *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, "ns2:column", &(a->ns2__ValueTable::column), "ns2:ValueTableColumn"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, "ns2:index", &(a->ns2__ValueTable::index), "ns2:ValueTableIndex"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, "ns2:row", &(a->ns2__ValueTable::row), "ns2:ValueTableRow"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueTable, 0, sizeof(ns2__ValueTable), 0, soap_copy_ns2__ValueTable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueTable);
	if (this->soap_out(soap, tag?tag:"ns2:ValueTable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueTable(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueTable * SOAP_FMAC4 soap_get_ns2__ValueTable(struct soap *soap, ns2__ValueTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueTable * SOAP_FMAC2 soap_instantiate_ns2__ValueTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueTable);
		if (size)
			*size = sizeof(ns2__ValueTable);
		((ns2__ValueTable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueTable, n);
		if (size)
			*size = n * sizeof(ns2__ValueTable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueTable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueTable %p -> %p\n", q, p));
	*(ns2__ValueTable*)p = *(ns2__ValueTable*)q;
}

void ns2__ValueListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ValueListType::valueType = NULL;
	this->ns2__ValueListType::availableValues = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, &this->ns2__ValueListType::item);
	this->ns2__ValueListType::lastId = NULL;
	/* transient soap skipped */
}

void ns2__ValueListType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__TypeDescription(soap, &this->ns2__ValueListType::valueType);
	soap_serialize_PointerTons2__ValueListType(soap, &this->ns2__ValueListType::availableValues);
	soap_serialize_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, &this->ns2__ValueListType::item);
	soap_serialize_PointerToLONG64(soap, &this->ns2__ValueListType::lastId);
	/* transient soap skipped */
#endif
}

int ns2__ValueListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueListType(struct soap *soap, const char *tag, int id, const ns2__ValueListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueListType), type))
		return soap->error;
	if (a->ns2__ValueListType::valueType)
	{	if (soap_out_PointerTons2__TypeDescription(soap, "ns2:valueType", -1, &a->ns2__ValueListType::valueType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:valueType"))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "ns2:availableValues", -1, &(a->ns2__ValueListType::availableValues), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, "ns2:item", -1, &(a->ns2__ValueListType::item), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns2:lastId", -1, &(a->ns2__ValueListType::lastId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueListType * SOAP_FMAC4 soap_in_ns2__ValueListType(struct soap *soap, const char *tag, ns2__ValueListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueListType, sizeof(ns2__ValueListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueListType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_valueType1 = 1;
	size_t soap_flag_availableValues1 = 1;
	size_t soap_flag_lastId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_valueType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TypeDescription(soap, "ns2:valueType", &(a->ns2__ValueListType::valueType), "ns2:TypeDescription"))
				{	soap_flag_valueType1--;
					continue;
				}
			if (soap_flag_availableValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "ns2:availableValues", &(a->ns2__ValueListType::availableValues), "ns2:ValueListType"))
				{	soap_flag_availableValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, "ns2:item", &(a->ns2__ValueListType::item), "ns2:ValueListItemType"))
					continue;
			if (soap_flag_lastId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns2:lastId", &(a->ns2__ValueListType::lastId), "xsd:long"))
				{	soap_flag_lastId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueListType, 0, sizeof(ns2__ValueListType), 0, soap_copy_ns2__ValueListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_valueType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ValueListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueListType);
	if (this->soap_out(soap, tag?tag:"ns2:ValueListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueListType * SOAP_FMAC4 soap_get_ns2__ValueListType(struct soap *soap, ns2__ValueListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueListType * SOAP_FMAC2 soap_instantiate_ns2__ValueListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueListType);
		if (size)
			*size = sizeof(ns2__ValueListType);
		((ns2__ValueListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueListType, n);
		if (size)
			*size = n * sizeof(ns2__ValueListType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueListType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueListType %p -> %p\n", q, p));
	*(ns2__ValueListType*)p = *(ns2__ValueListType*)q;
}

void ns2__ValueListItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ValueListItemType::value = NULL;
	this->ns2__ValueListItemType::presentation = NULL;
	this->ns2__ValueListItemType::checkState = NULL;
	this->ns2__ValueListItemType::picture = NULL;
	this->ns2__ValueListItemType::id = NULL;
	/* transient soap skipped */
}

void ns2__ValueListItemType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__ValueListItemType::presentation);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns2__ValueListItemType::checkState);
	soap_serialize_PointerToLONG64(soap, &this->ns2__ValueListItemType::id);
	/* transient soap skipped */
#endif
}

int ns2__ValueListItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValueListItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValueListItemType(struct soap *soap, const char *tag, int id, const ns2__ValueListItemType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValueListItemType), type))
		return soap->error;
	soap_outliteral(soap, "ns2:value", &(a->ns2__ValueListItemType::value), NULL);
	if (soap_out_PointerTostd__string(soap, "ns2:presentation", -1, &(a->ns2__ValueListItemType::presentation), ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns2:checkState", -1, &(a->ns2__ValueListItemType::checkState), ""))
		return soap->error;
	soap_outliteral(soap, "ns2:picture", &(a->ns2__ValueListItemType::picture), NULL);
	if (soap_out_PointerToLONG64(soap, "ns2:id", -1, &(a->ns2__ValueListItemType::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValueListItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValueListItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValueListItemType * SOAP_FMAC4 soap_in_ns2__ValueListItemType(struct soap *soap, const char *tag, ns2__ValueListItemType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValueListItemType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValueListItemType, sizeof(ns2__ValueListItemType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValueListItemType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValueListItemType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	size_t soap_flag_presentation1 = 1;
	size_t soap_flag_checkState1 = 1;
	size_t soap_flag_picture1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:value", &(a->ns2__ValueListItemType::value)))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_presentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:presentation", &(a->ns2__ValueListItemType::presentation), "xsd:string"))
				{	soap_flag_presentation1--;
					continue;
				}
			if (soap_flag_checkState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "ns2:checkState", &(a->ns2__ValueListItemType::checkState), "xsd:decimal"))
				{	soap_flag_checkState1--;
					continue;
				}
			if (soap_flag_picture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:picture", &(a->ns2__ValueListItemType::picture)))
				{	soap_flag_picture1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns2:id", &(a->ns2__ValueListItemType::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValueListItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValueListItemType, 0, sizeof(ns2__ValueListItemType), 0, soap_copy_ns2__ValueListItemType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ValueListItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValueListItemType);
	if (this->soap_out(soap, tag?tag:"ns2:ValueListItemType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValueListItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValueListItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValueListItemType * SOAP_FMAC4 soap_get_ns2__ValueListItemType(struct soap *soap, ns2__ValueListItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValueListItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValueListItemType * SOAP_FMAC2 soap_instantiate_ns2__ValueListItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValueListItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValueListItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValueListItemType);
		if (size)
			*size = sizeof(ns2__ValueListItemType);
		((ns2__ValueListItemType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValueListItemType, n);
		if (size)
			*size = n * sizeof(ns2__ValueListItemType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValueListItemType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValueListItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValueListItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValueListItemType %p -> %p\n", q, p));
	*(ns2__ValueListItemType*)p = *(ns2__ValueListItemType*)q;
}

void ns2__TypeDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns2__TypeDescription::Type);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns2__TypeDescription::TypeSet);
	soap_default_std__vectorTemplateOfns2__UUID(soap, &this->ns2__TypeDescription::TypeId);
	this->ns2__TypeDescription::NumberQualifiers = NULL;
	this->ns2__TypeDescription::StringQualifiers = NULL;
	this->ns2__TypeDescription::DateQualifiers = NULL;
	this->ns2__TypeDescription::BinaryDataQualifiers = NULL;
	/* transient soap skipped */
}

void ns2__TypeDescription::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns2__TypeDescription::Type);
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns2__TypeDescription::TypeSet);
	soap_serialize_std__vectorTemplateOfns2__UUID(soap, &this->ns2__TypeDescription::TypeId);
	soap_serialize_PointerTons2__NumberQualifiers(soap, &this->ns2__TypeDescription::NumberQualifiers);
	soap_serialize_PointerTons2__StringQualifiers(soap, &this->ns2__TypeDescription::StringQualifiers);
	soap_serialize_PointerTons2__DateQualifiers(soap, &this->ns2__TypeDescription::DateQualifiers);
	soap_serialize_PointerTons2__BinaryDataQualifiers(soap, &this->ns2__TypeDescription::BinaryDataQualifiers);
	/* transient soap skipped */
#endif
}

int ns2__TypeDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TypeDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TypeDescription(struct soap *soap, const char *tag, int id, const ns2__TypeDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TypeDescription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns2:Type", -1, &(a->ns2__TypeDescription::Type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns2:TypeSet", -1, &(a->ns2__TypeDescription::TypeSet), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__UUID(soap, "ns2:TypeId", -1, &(a->ns2__TypeDescription::TypeId), ""))
		return soap->error;
	if (soap_out_PointerTons2__NumberQualifiers(soap, "ns2:NumberQualifiers", -1, &(a->ns2__TypeDescription::NumberQualifiers), ""))
		return soap->error;
	if (soap_out_PointerTons2__StringQualifiers(soap, "ns2:StringQualifiers", -1, &(a->ns2__TypeDescription::StringQualifiers), ""))
		return soap->error;
	if (soap_out_PointerTons2__DateQualifiers(soap, "ns2:DateQualifiers", -1, &(a->ns2__TypeDescription::DateQualifiers), ""))
		return soap->error;
	if (soap_out_PointerTons2__BinaryDataQualifiers(soap, "ns2:BinaryDataQualifiers", -1, &(a->ns2__TypeDescription::BinaryDataQualifiers), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__TypeDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TypeDescription(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TypeDescription * SOAP_FMAC4 soap_in_ns2__TypeDescription(struct soap *soap, const char *tag, ns2__TypeDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TypeDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TypeDescription, sizeof(ns2__TypeDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TypeDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__TypeDescription *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NumberQualifiers1 = 1;
	size_t soap_flag_StringQualifiers1 = 1;
	size_t soap_flag_DateQualifiers1 = 1;
	size_t soap_flag_BinaryDataQualifiers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns2:Type", &(a->ns2__TypeDescription::Type), "xsd:QName"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns2:TypeSet", &(a->ns2__TypeDescription::TypeSet), "xsd:QName"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__UUID(soap, "ns2:TypeId", &(a->ns2__TypeDescription::TypeId), "ns2:UUID"))
					continue;
			if (soap_flag_NumberQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NumberQualifiers(soap, "ns2:NumberQualifiers", &(a->ns2__TypeDescription::NumberQualifiers), "ns2:NumberQualifiers"))
				{	soap_flag_NumberQualifiers1--;
					continue;
				}
			if (soap_flag_StringQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__StringQualifiers(soap, "ns2:StringQualifiers", &(a->ns2__TypeDescription::StringQualifiers), "ns2:StringQualifiers"))
				{	soap_flag_StringQualifiers1--;
					continue;
				}
			if (soap_flag_DateQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DateQualifiers(soap, "ns2:DateQualifiers", &(a->ns2__TypeDescription::DateQualifiers), "ns2:DateQualifiers"))
				{	soap_flag_DateQualifiers1--;
					continue;
				}
			if (soap_flag_BinaryDataQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryDataQualifiers(soap, "ns2:BinaryDataQualifiers", &(a->ns2__TypeDescription::BinaryDataQualifiers), "ns2:BinaryDataQualifiers"))
				{	soap_flag_BinaryDataQualifiers1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TypeDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TypeDescription, 0, sizeof(ns2__TypeDescription), 0, soap_copy_ns2__TypeDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__TypeDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TypeDescription);
	if (this->soap_out(soap, tag?tag:"ns2:TypeDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TypeDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TypeDescription(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TypeDescription * SOAP_FMAC4 soap_get_ns2__TypeDescription(struct soap *soap, ns2__TypeDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TypeDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TypeDescription * SOAP_FMAC2 soap_instantiate_ns2__TypeDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TypeDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TypeDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TypeDescription);
		if (size)
			*size = sizeof(ns2__TypeDescription);
		((ns2__TypeDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__TypeDescription, n);
		if (size)
			*size = n * sizeof(ns2__TypeDescription);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__TypeDescription*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__TypeDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TypeDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TypeDescription %p -> %p\n", q, p));
	*(ns2__TypeDescription*)p = *(ns2__TypeDescription*)q;
}

void ns2__Structure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Structure::Property = NULL;
	/* transient soap skipped */
}

void ns2__Structure::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_ns2__Structure_Property(soap, &this->ns2__Structure::Property);
	/* transient soap skipped */
#endif
}

int ns2__Structure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Structure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Structure(struct soap *soap, const char *tag, int id, const ns2__Structure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Structure), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__Structure_Property(soap, "ns2:Property", -1, &(a->ns2__Structure::Property), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Structure::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Structure(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Structure * SOAP_FMAC4 soap_in_ns2__Structure(struct soap *soap, const char *tag, ns2__Structure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Structure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Structure, sizeof(ns2__Structure), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Structure)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Structure *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_ns2__Structure_Property(soap, "ns2:Property", &(a->ns2__Structure::Property), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Structure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Structure, 0, sizeof(ns2__Structure), 0, soap_copy_ns2__Structure);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Structure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Structure);
	if (this->soap_out(soap, tag?tag:"ns2:Structure", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Structure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Structure(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Structure * SOAP_FMAC4 soap_get_ns2__Structure(struct soap *soap, ns2__Structure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Structure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Structure * SOAP_FMAC2 soap_instantiate_ns2__Structure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Structure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Structure, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Structure);
		if (size)
			*size = sizeof(ns2__Structure);
		((ns2__Structure*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Structure, n);
		if (size)
			*size = n * sizeof(ns2__Structure);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Structure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Structure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Structure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Structure %p -> %p\n", q, p));
	*(ns2__Structure*)p = *(ns2__Structure*)q;
}

void ns2__StringQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns2__StringQualifiers::Length);
	soap_default_ns2__AllowedLength(soap, &this->ns2__StringQualifiers::AllowedLength);
	/* transient soap skipped */
}

void ns2__StringQualifiers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__StringQualifiers::Length, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns2__StringQualifiers::Length);
	/* transient soap skipped */
#endif
}

int ns2__StringQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StringQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StringQualifiers(struct soap *soap, const char *tag, int id, const ns2__StringQualifiers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StringQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns2:Length", -1, &(a->ns2__StringQualifiers::Length), ""))
		return soap->error;
	if (soap_out_ns2__AllowedLength(soap, "ns2:AllowedLength", -1, &(a->ns2__StringQualifiers::AllowedLength), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__StringQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StringQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StringQualifiers * SOAP_FMAC4 soap_in_ns2__StringQualifiers(struct soap *soap, const char *tag, ns2__StringQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StringQualifiers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StringQualifiers, sizeof(ns2__StringQualifiers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__StringQualifiers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__StringQualifiers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Length1 = 1;
	size_t soap_flag_AllowedLength1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns2:Length", &(a->ns2__StringQualifiers::Length), "xsd:decimal"))
				{	soap_flag_Length1--;
					continue;
				}
			if (soap_flag_AllowedLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AllowedLength(soap, "ns2:AllowedLength", &(a->ns2__StringQualifiers::AllowedLength), "ns2:AllowedLength"))
				{	soap_flag_AllowedLength1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StringQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StringQualifiers, 0, sizeof(ns2__StringQualifiers), 0, soap_copy_ns2__StringQualifiers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Length1 > 0 || soap_flag_AllowedLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__StringQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__StringQualifiers);
	if (this->soap_out(soap, tag?tag:"ns2:StringQualifiers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StringQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StringQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StringQualifiers * SOAP_FMAC4 soap_get_ns2__StringQualifiers(struct soap *soap, ns2__StringQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StringQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__StringQualifiers * SOAP_FMAC2 soap_instantiate_ns2__StringQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StringQualifiers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__StringQualifiers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__StringQualifiers);
		if (size)
			*size = sizeof(ns2__StringQualifiers);
		((ns2__StringQualifiers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__StringQualifiers, n);
		if (size)
			*size = n * sizeof(ns2__StringQualifiers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__StringQualifiers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__StringQualifiers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__StringQualifiers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__StringQualifiers %p -> %p\n", q, p));
	*(ns2__StringQualifiers*)p = *(ns2__StringQualifiers*)q;
}

void ns2__StandardPeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__StandardPeriod::variant = NULL;
	this->ns2__StandardPeriod::startDate = NULL;
	this->ns2__StandardPeriod::endDate = NULL;
	/* transient soap skipped */
}

void ns2__StandardPeriod::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns2__StandardPeriod::startDate);
	soap_serialize_PointerTotime(soap, &this->ns2__StandardPeriod::endDate);
	/* transient soap skipped */
#endif
}

int ns2__StandardPeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StandardPeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StandardPeriod(struct soap *soap, const char *tag, int id, const ns2__StandardPeriod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StandardPeriod), type))
		return soap->error;
	soap_outliteral(soap, "ns2:variant", &(a->ns2__StandardPeriod::variant), NULL);
	if (soap_out_PointerTotime(soap, "ns2:startDate", -1, &(a->ns2__StandardPeriod::startDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns2:endDate", -1, &(a->ns2__StandardPeriod::endDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__StandardPeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StandardPeriod(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StandardPeriod * SOAP_FMAC4 soap_in_ns2__StandardPeriod(struct soap *soap, const char *tag, ns2__StandardPeriod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StandardPeriod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StandardPeriod, sizeof(ns2__StandardPeriod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__StandardPeriod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__StandardPeriod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_variant1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_variant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:variant", &(a->ns2__StandardPeriod::variant)))
				{	soap_flag_variant1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns2:startDate", &(a->ns2__StandardPeriod::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns2:endDate", &(a->ns2__StandardPeriod::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StandardPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StandardPeriod, 0, sizeof(ns2__StandardPeriod), 0, soap_copy_ns2__StandardPeriod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_variant1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__StandardPeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__StandardPeriod);
	if (this->soap_out(soap, tag?tag:"ns2:StandardPeriod", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StandardPeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StandardPeriod(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StandardPeriod * SOAP_FMAC4 soap_get_ns2__StandardPeriod(struct soap *soap, ns2__StandardPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StandardPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__StandardPeriod * SOAP_FMAC2 soap_instantiate_ns2__StandardPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StandardPeriod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__StandardPeriod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__StandardPeriod);
		if (size)
			*size = sizeof(ns2__StandardPeriod);
		((ns2__StandardPeriod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__StandardPeriod, n);
		if (size)
			*size = n * sizeof(ns2__StandardPeriod);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__StandardPeriod*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__StandardPeriod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__StandardPeriod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__StandardPeriod %p -> %p\n", q, p));
	*(ns2__StandardPeriod*)p = *(ns2__StandardPeriod*)q;
}

void ns2__StandardBeginningDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__StandardBeginningDate::variant = NULL;
	this->ns2__StandardBeginningDate::date = NULL;
	/* transient soap skipped */
}

void ns2__StandardBeginningDate::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns2__StandardBeginningDate::date);
	/* transient soap skipped */
#endif
}

int ns2__StandardBeginningDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StandardBeginningDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StandardBeginningDate(struct soap *soap, const char *tag, int id, const ns2__StandardBeginningDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StandardBeginningDate), type))
		return soap->error;
	soap_outliteral(soap, "ns2:variant", &(a->ns2__StandardBeginningDate::variant), NULL);
	if (soap_out_PointerTotime(soap, "ns2:date", -1, &(a->ns2__StandardBeginningDate::date), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__StandardBeginningDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StandardBeginningDate(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StandardBeginningDate * SOAP_FMAC4 soap_in_ns2__StandardBeginningDate(struct soap *soap, const char *tag, ns2__StandardBeginningDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StandardBeginningDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StandardBeginningDate, sizeof(ns2__StandardBeginningDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__StandardBeginningDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__StandardBeginningDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_variant1 = 1;
	size_t soap_flag_date1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_variant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:variant", &(a->ns2__StandardBeginningDate::variant)))
				{	soap_flag_variant1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns2:date", &(a->ns2__StandardBeginningDate::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StandardBeginningDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StandardBeginningDate, 0, sizeof(ns2__StandardBeginningDate), 0, soap_copy_ns2__StandardBeginningDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_variant1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__StandardBeginningDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__StandardBeginningDate);
	if (this->soap_out(soap, tag?tag:"ns2:StandardBeginningDate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StandardBeginningDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StandardBeginningDate(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StandardBeginningDate * SOAP_FMAC4 soap_get_ns2__StandardBeginningDate(struct soap *soap, ns2__StandardBeginningDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StandardBeginningDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__StandardBeginningDate * SOAP_FMAC2 soap_instantiate_ns2__StandardBeginningDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StandardBeginningDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__StandardBeginningDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__StandardBeginningDate);
		if (size)
			*size = sizeof(ns2__StandardBeginningDate);
		((ns2__StandardBeginningDate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__StandardBeginningDate, n);
		if (size)
			*size = n * sizeof(ns2__StandardBeginningDate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__StandardBeginningDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__StandardBeginningDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__StandardBeginningDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__StandardBeginningDate %p -> %p\n", q, p));
	*(ns2__StandardBeginningDate*)p = *(ns2__StandardBeginningDate*)q;
}

void ns2__NumberQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns2__NumberQualifiers::Digits);
	soap_default_xsd__decimal(soap, &this->ns2__NumberQualifiers::FractionDigits);
	soap_default_ns2__AllowedSign(soap, &this->ns2__NumberQualifiers::AllowedSign);
	/* transient soap skipped */
}

void ns2__NumberQualifiers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__NumberQualifiers::Digits, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns2__NumberQualifiers::Digits);
	soap_embedded(soap, &this->ns2__NumberQualifiers::FractionDigits, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns2__NumberQualifiers::FractionDigits);
	/* transient soap skipped */
#endif
}

int ns2__NumberQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NumberQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NumberQualifiers(struct soap *soap, const char *tag, int id, const ns2__NumberQualifiers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NumberQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns2:Digits", -1, &(a->ns2__NumberQualifiers::Digits), ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns2:FractionDigits", -1, &(a->ns2__NumberQualifiers::FractionDigits), ""))
		return soap->error;
	if (soap_out_ns2__AllowedSign(soap, "ns2:AllowedSign", -1, &(a->ns2__NumberQualifiers::AllowedSign), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NumberQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NumberQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NumberQualifiers * SOAP_FMAC4 soap_in_ns2__NumberQualifiers(struct soap *soap, const char *tag, ns2__NumberQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NumberQualifiers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NumberQualifiers, sizeof(ns2__NumberQualifiers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NumberQualifiers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NumberQualifiers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Digits1 = 1;
	size_t soap_flag_FractionDigits1 = 1;
	size_t soap_flag_AllowedSign1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Digits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns2:Digits", &(a->ns2__NumberQualifiers::Digits), "xsd:decimal"))
				{	soap_flag_Digits1--;
					continue;
				}
			if (soap_flag_FractionDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns2:FractionDigits", &(a->ns2__NumberQualifiers::FractionDigits), "xsd:decimal"))
				{	soap_flag_FractionDigits1--;
					continue;
				}
			if (soap_flag_AllowedSign1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AllowedSign(soap, "ns2:AllowedSign", &(a->ns2__NumberQualifiers::AllowedSign), "ns2:AllowedSign"))
				{	soap_flag_AllowedSign1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NumberQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NumberQualifiers, 0, sizeof(ns2__NumberQualifiers), 0, soap_copy_ns2__NumberQualifiers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Digits1 > 0 || soap_flag_FractionDigits1 > 0 || soap_flag_AllowedSign1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NumberQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NumberQualifiers);
	if (this->soap_out(soap, tag?tag:"ns2:NumberQualifiers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NumberQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NumberQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NumberQualifiers * SOAP_FMAC4 soap_get_ns2__NumberQualifiers(struct soap *soap, ns2__NumberQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NumberQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NumberQualifiers * SOAP_FMAC2 soap_instantiate_ns2__NumberQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NumberQualifiers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NumberQualifiers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NumberQualifiers);
		if (size)
			*size = sizeof(ns2__NumberQualifiers);
		((ns2__NumberQualifiers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NumberQualifiers, n);
		if (size)
			*size = n * sizeof(ns2__NumberQualifiers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NumberQualifiers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NumberQualifiers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NumberQualifiers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NumberQualifiers %p -> %p\n", q, p));
	*(ns2__NumberQualifiers*)p = *(ns2__NumberQualifiers*)q;
}

void ns2__Map::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, &this->ns2__Map::pair);
	/* transient soap skipped */
}

void ns2__Map::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, &this->ns2__Map::pair);
	/* transient soap skipped */
#endif
}

int ns2__Map::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Map(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Map(struct soap *soap, const char *tag, int id, const ns2__Map *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Map), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, "ns2:pair", -1, &(a->ns2__Map::pair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Map::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Map(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_in_ns2__Map(struct soap *soap, const char *tag, ns2__Map *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Map *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Map)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Map *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, "ns2:pair", &(a->ns2__Map::pair), "ns2:KeyAndValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Map *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Map, 0, sizeof(ns2__Map), 0, soap_copy_ns2__Map);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Map::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Map);
	if (this->soap_out(soap, tag?tag:"ns2:Map", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Map::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Map(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_get_ns2__Map(struct soap *soap, ns2__Map *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Map * SOAP_FMAC2 soap_instantiate_ns2__Map(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Map(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Map, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Map);
		if (size)
			*size = sizeof(ns2__Map);
		((ns2__Map*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Map, n);
		if (size)
			*size = n * sizeof(ns2__Map);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Map*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Map*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Map(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Map %p -> %p\n", q, p));
	*(ns2__Map*)p = *(ns2__Map*)q;
}

void ns2__LocalStringType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, &this->ns2__LocalStringType::item);
	/* transient soap skipped */
}

void ns2__LocalStringType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, &this->ns2__LocalStringType::item);
	/* transient soap skipped */
#endif
}

int ns2__LocalStringType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LocalStringType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LocalStringType(struct soap *soap, const char *tag, int id, const ns2__LocalStringType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LocalStringType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, "ns2:item", -1, &(a->ns2__LocalStringType::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LocalStringType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LocalStringType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LocalStringType * SOAP_FMAC4 soap_in_ns2__LocalStringType(struct soap *soap, const char *tag, ns2__LocalStringType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LocalStringType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LocalStringType, sizeof(ns2__LocalStringType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LocalStringType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LocalStringType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, "ns2:item", &(a->ns2__LocalStringType::item), "ns2:LocalStringItemType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LocalStringType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LocalStringType, 0, sizeof(ns2__LocalStringType), 0, soap_copy_ns2__LocalStringType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__LocalStringType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LocalStringType);
	if (this->soap_out(soap, tag?tag:"ns2:LocalStringType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LocalStringType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LocalStringType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LocalStringType * SOAP_FMAC4 soap_get_ns2__LocalStringType(struct soap *soap, ns2__LocalStringType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LocalStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LocalStringType * SOAP_FMAC2 soap_instantiate_ns2__LocalStringType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LocalStringType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LocalStringType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocalStringType);
		if (size)
			*size = sizeof(ns2__LocalStringType);
		((ns2__LocalStringType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__LocalStringType, n);
		if (size)
			*size = n * sizeof(ns2__LocalStringType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__LocalStringType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__LocalStringType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LocalStringType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LocalStringType %p -> %p\n", q, p));
	*(ns2__LocalStringType*)p = *(ns2__LocalStringType*)q;
}

void ns2__LocalStringItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NMTOKEN(soap, &this->ns2__LocalStringItemType::lang);
	soap_default_std__string(soap, &this->ns2__LocalStringItemType::content);
	/* transient soap skipped */
}

void ns2__LocalStringItemType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__LocalStringItemType::lang, SOAP_TYPE_xsd__NMTOKEN);
	soap_serialize_xsd__NMTOKEN(soap, &this->ns2__LocalStringItemType::lang);
	soap_embedded(soap, &this->ns2__LocalStringItemType::content, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LocalStringItemType::content);
	/* transient soap skipped */
#endif
}

int ns2__LocalStringItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LocalStringItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LocalStringItemType(struct soap *soap, const char *tag, int id, const ns2__LocalStringItemType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LocalStringItemType), type))
		return soap->error;
	if (soap_out_xsd__NMTOKEN(soap, "ns2:lang", -1, &(a->ns2__LocalStringItemType::lang), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:content", -1, &(a->ns2__LocalStringItemType::content), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LocalStringItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LocalStringItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LocalStringItemType * SOAP_FMAC4 soap_in_ns2__LocalStringItemType(struct soap *soap, const char *tag, ns2__LocalStringItemType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LocalStringItemType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LocalStringItemType, sizeof(ns2__LocalStringItemType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LocalStringItemType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LocalStringItemType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lang1 = 1;
	size_t soap_flag_content1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lang1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__NMTOKEN(soap, "ns2:lang", &(a->ns2__LocalStringItemType::lang), "xsd:NMTOKEN"))
				{	soap_flag_lang1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:content", &(a->ns2__LocalStringItemType::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LocalStringItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LocalStringItemType, 0, sizeof(ns2__LocalStringItemType), 0, soap_copy_ns2__LocalStringItemType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lang1 > 0 || soap_flag_content1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LocalStringItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LocalStringItemType);
	if (this->soap_out(soap, tag?tag:"ns2:LocalStringItemType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LocalStringItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LocalStringItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LocalStringItemType * SOAP_FMAC4 soap_get_ns2__LocalStringItemType(struct soap *soap, ns2__LocalStringItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LocalStringItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LocalStringItemType * SOAP_FMAC2 soap_instantiate_ns2__LocalStringItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LocalStringItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LocalStringItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocalStringItemType);
		if (size)
			*size = sizeof(ns2__LocalStringItemType);
		((ns2__LocalStringItemType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__LocalStringItemType, n);
		if (size)
			*size = n * sizeof(ns2__LocalStringItemType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__LocalStringItemType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__LocalStringItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LocalStringItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LocalStringItemType %p -> %p\n", q, p));
	*(ns2__LocalStringItemType*)p = *(ns2__LocalStringItemType*)q;
}

void ns2__KeyAndValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__KeyAndValue::Key = NULL;
	this->ns2__KeyAndValue::Value = NULL;
	/* transient soap skipped */
}

void ns2__KeyAndValue::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__KeyAndValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__KeyAndValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__KeyAndValue(struct soap *soap, const char *tag, int id, const ns2__KeyAndValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__KeyAndValue), type))
		return soap->error;
	soap_outliteral(soap, "ns2:Key", &(a->ns2__KeyAndValue::Key), NULL);
	soap_outliteral(soap, "ns2:Value", &(a->ns2__KeyAndValue::Value), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__KeyAndValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__KeyAndValue(soap, tag, this, type);
}

SOAP_FMAC3 ns2__KeyAndValue * SOAP_FMAC4 soap_in_ns2__KeyAndValue(struct soap *soap, const char *tag, ns2__KeyAndValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__KeyAndValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__KeyAndValue, sizeof(ns2__KeyAndValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__KeyAndValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__KeyAndValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Key", &(a->ns2__KeyAndValue::Key)))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns2:Value", &(a->ns2__KeyAndValue::Value)))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__KeyAndValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__KeyAndValue, 0, sizeof(ns2__KeyAndValue), 0, soap_copy_ns2__KeyAndValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Key1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__KeyAndValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__KeyAndValue);
	if (this->soap_out(soap, tag?tag:"ns2:KeyAndValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__KeyAndValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__KeyAndValue(soap, this, tag, type);
}

SOAP_FMAC3 ns2__KeyAndValue * SOAP_FMAC4 soap_get_ns2__KeyAndValue(struct soap *soap, ns2__KeyAndValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__KeyAndValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__KeyAndValue * SOAP_FMAC2 soap_instantiate_ns2__KeyAndValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__KeyAndValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__KeyAndValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeyAndValue);
		if (size)
			*size = sizeof(ns2__KeyAndValue);
		((ns2__KeyAndValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__KeyAndValue, n);
		if (size)
			*size = n * sizeof(ns2__KeyAndValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__KeyAndValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__KeyAndValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__KeyAndValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__KeyAndValue %p -> %p\n", q, p));
	*(ns2__KeyAndValue*)p = *(ns2__KeyAndValue*)q;
}

void ns2__GenericException::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__GenericException::descr);
	this->ns2__GenericException::inner = NULL;
	soap_default_ns2__UUID(soap, &this->ns2__GenericException::clsid);
	this->ns2__GenericException::encoded = (bool)0;
	/* transient soap skipped */
}

void ns2__GenericException::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__GenericException::descr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__GenericException::descr);
	soap_serialize_PointerTons2__GenericException(soap, &this->ns2__GenericException::inner);
	/* transient soap skipped */
#endif
}

int ns2__GenericException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GenericException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GenericException(struct soap *soap, const char *tag, int id, const ns2__GenericException *a, const char *type)
{
	soap_set_attr(soap, "clsid", ((ns2__GenericException*)a)->clsid.c_str(), 1);
	soap_set_attr(soap, "encoded", soap_bool2s(soap, ((ns2__GenericException*)a)->encoded), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GenericException), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:descr", -1, &(a->ns2__GenericException::descr), ""))
		return soap->error;
	if (soap_out_PointerTons2__GenericException(soap, "ns2:inner", -1, &(a->ns2__GenericException::inner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__GenericException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GenericException(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GenericException * SOAP_FMAC4 soap_in_ns2__GenericException(struct soap *soap, const char *tag, ns2__GenericException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GenericException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GenericException, sizeof(ns2__GenericException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GenericException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GenericException *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "clsid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__GenericException*)a)->clsid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "encoded", 0), &((ns2__GenericException*)a)->encoded))
		return NULL;
	size_t soap_flag_descr1 = 1;
	size_t soap_flag_inner1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:descr", &(a->ns2__GenericException::descr), "xsd:string"))
				{	soap_flag_descr1--;
					continue;
				}
			if (soap_flag_inner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GenericException(soap, "ns2:inner", &(a->ns2__GenericException::inner), "ns2:GenericException"))
				{	soap_flag_inner1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GenericException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GenericException, 0, sizeof(ns2__GenericException), 0, soap_copy_ns2__GenericException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_descr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__GenericException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GenericException);
	if (this->soap_out(soap, tag?tag:"ns2:GenericException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GenericException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GenericException(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GenericException * SOAP_FMAC4 soap_get_ns2__GenericException(struct soap *soap, ns2__GenericException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GenericException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GenericException * SOAP_FMAC2 soap_instantiate_ns2__GenericException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GenericException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GenericException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:Exception"))
	{	cp->type = SOAP_TYPE_ns2__Exception;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__Exception);
			if (size)
				*size = sizeof(ns2__Exception);
			((ns2__Exception*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Exception, n);
			if (size)
				*size = n * sizeof(ns2__Exception);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__Exception*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__Exception*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GenericException);
		if (size)
			*size = sizeof(ns2__GenericException);
		((ns2__GenericException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GenericException, n);
		if (size)
			*size = n * sizeof(ns2__GenericException);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GenericException*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GenericException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GenericException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GenericException %p -> %p\n", q, p));
	*(ns2__GenericException*)p = *(ns2__GenericException*)q;
}

void ns2__FixedStructure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FixedStructure::Property = NULL;
	/* transient soap skipped */
}

void ns2__FixedStructure::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(soap, &this->ns2__FixedStructure::Property);
	/* transient soap skipped */
#endif
}

int ns2__FixedStructure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FixedStructure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FixedStructure(struct soap *soap, const char *tag, int id, const ns2__FixedStructure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FixedStructure), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(soap, "ns2:Property", -1, &(a->ns2__FixedStructure::Property), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FixedStructure::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FixedStructure(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FixedStructure * SOAP_FMAC4 soap_in_ns2__FixedStructure(struct soap *soap, const char *tag, ns2__FixedStructure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FixedStructure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FixedStructure, sizeof(ns2__FixedStructure), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FixedStructure)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FixedStructure *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(soap, "ns2:Property", &(a->ns2__FixedStructure::Property), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FixedStructure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FixedStructure, 0, sizeof(ns2__FixedStructure), 0, soap_copy_ns2__FixedStructure);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FixedStructure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FixedStructure);
	if (this->soap_out(soap, tag?tag:"ns2:FixedStructure", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FixedStructure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FixedStructure(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FixedStructure * SOAP_FMAC4 soap_get_ns2__FixedStructure(struct soap *soap, ns2__FixedStructure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FixedStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FixedStructure * SOAP_FMAC2 soap_instantiate_ns2__FixedStructure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FixedStructure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FixedStructure, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FixedStructure);
		if (size)
			*size = sizeof(ns2__FixedStructure);
		((ns2__FixedStructure*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FixedStructure, n);
		if (size)
			*size = n * sizeof(ns2__FixedStructure);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FixedStructure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FixedStructure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FixedStructure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FixedStructure %p -> %p\n", q, p));
	*(ns2__FixedStructure*)p = *(ns2__FixedStructure*)q;
}

void ns2__FixedMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, &this->ns2__FixedMap::pair);
	/* transient soap skipped */
}

void ns2__FixedMap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, &this->ns2__FixedMap::pair);
	/* transient soap skipped */
#endif
}

int ns2__FixedMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FixedMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FixedMap(struct soap *soap, const char *tag, int id, const ns2__FixedMap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FixedMap), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, "ns2:pair", -1, &(a->ns2__FixedMap::pair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FixedMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FixedMap(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FixedMap * SOAP_FMAC4 soap_in_ns2__FixedMap(struct soap *soap, const char *tag, ns2__FixedMap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FixedMap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FixedMap, sizeof(ns2__FixedMap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FixedMap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FixedMap *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, "ns2:pair", &(a->ns2__FixedMap::pair), "ns2:KeyAndValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FixedMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FixedMap, 0, sizeof(ns2__FixedMap), 0, soap_copy_ns2__FixedMap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FixedMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FixedMap);
	if (this->soap_out(soap, tag?tag:"ns2:FixedMap", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FixedMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FixedMap(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FixedMap * SOAP_FMAC4 soap_get_ns2__FixedMap(struct soap *soap, ns2__FixedMap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FixedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FixedMap * SOAP_FMAC2 soap_instantiate_ns2__FixedMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FixedMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FixedMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FixedMap);
		if (size)
			*size = sizeof(ns2__FixedMap);
		((ns2__FixedMap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FixedMap, n);
		if (size)
			*size = n * sizeof(ns2__FixedMap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FixedMap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FixedMap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FixedMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FixedMap %p -> %p\n", q, p));
	*(ns2__FixedMap*)p = *(ns2__FixedMap*)q;
}

void ns2__FixedArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__FixedArray::Value);
	/* transient soap skipped */
}

void ns2__FixedArray::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__FixedArray::Value);
	/* transient soap skipped */
#endif
}

int ns2__FixedArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FixedArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FixedArray(struct soap *soap, const char *tag, int id, const ns2__FixedArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FixedArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns2:Value", -1, &(a->ns2__FixedArray::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FixedArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FixedArray(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FixedArray * SOAP_FMAC4 soap_in_ns2__FixedArray(struct soap *soap, const char *tag, ns2__FixedArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FixedArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FixedArray, sizeof(ns2__FixedArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FixedArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FixedArray *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "ns2:Value", &(a->ns2__FixedArray::Value), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FixedArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FixedArray, 0, sizeof(ns2__FixedArray), 0, soap_copy_ns2__FixedArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FixedArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FixedArray);
	if (this->soap_out(soap, tag?tag:"ns2:FixedArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FixedArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FixedArray(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FixedArray * SOAP_FMAC4 soap_get_ns2__FixedArray(struct soap *soap, ns2__FixedArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FixedArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FixedArray * SOAP_FMAC2 soap_instantiate_ns2__FixedArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FixedArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FixedArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FixedArray);
		if (size)
			*size = sizeof(ns2__FixedArray);
		((ns2__FixedArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FixedArray, n);
		if (size)
			*size = n * sizeof(ns2__FixedArray);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FixedArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FixedArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FixedArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FixedArray %p -> %p\n", q, p));
	*(ns2__FixedArray*)p = *(ns2__FixedArray*)q;
}

void ns2__Exception::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__GenericException::soap_default(soap);
	this->ns2__Exception::data = NULL;
}

void ns2__Exception::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns2__Exception::data);
	this->ns2__GenericException::soap_serialize(soap);
#endif
}

int ns2__Exception::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Exception(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Exception(struct soap *soap, const char *tag, int id, const ns2__Exception *a, const char *type)
{
	soap_set_attr(soap, "clsid", ((ns2__GenericException*)a)->clsid.c_str(), 1);
	soap_set_attr(soap, "encoded", soap_bool2s(soap, ((ns2__GenericException*)a)->encoded), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Exception), "ns2:Exception"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:descr", -1, &(a->ns2__GenericException::descr), ""))
		return soap->error;
	if (soap_out_PointerTons2__GenericException(soap, "ns2:inner", -1, &(a->ns2__GenericException::inner), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__base64Binary(soap, "ns2:data", -1, &(a->ns2__Exception::data), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Exception::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Exception(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Exception * SOAP_FMAC4 soap_in_ns2__Exception(struct soap *soap, const char *tag, ns2__Exception *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Exception *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Exception, sizeof(ns2__Exception), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Exception)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Exception *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "clsid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((ns2__GenericException*)a)->clsid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "encoded", 0), &((ns2__GenericException*)a)->encoded))
		return NULL;
	size_t soap_flag_descr2 = 1;
	size_t soap_flag_inner2 = 1;
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descr2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:descr", &(a->ns2__GenericException::descr), "xsd:string"))
				{	soap_flag_descr2--;
					continue;
				}
			if (soap_flag_inner2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GenericException(soap, "ns2:inner", &(a->ns2__GenericException::inner), "ns2:GenericException"))
				{	soap_flag_inner2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns2:data", &(a->ns2__Exception::data), "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Exception *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Exception, 0, sizeof(ns2__Exception), 0, soap_copy_ns2__Exception);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_descr2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__Exception::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Exception);
	if (this->soap_out(soap, tag?tag:"ns2:Exception", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Exception::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Exception(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Exception * SOAP_FMAC4 soap_get_ns2__Exception(struct soap *soap, ns2__Exception *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Exception(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Exception * SOAP_FMAC2 soap_instantiate_ns2__Exception(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Exception(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Exception, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Exception);
		if (size)
			*size = sizeof(ns2__Exception);
		((ns2__Exception*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Exception, n);
		if (size)
			*size = n * sizeof(ns2__Exception);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Exception*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Exception*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Exception(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Exception %p -> %p\n", q, p));
	*(ns2__Exception*)p = *(ns2__Exception*)q;
}

void ns2__DateQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__DateFractions(soap, &this->ns2__DateQualifiers::DateFractions);
	/* transient soap skipped */
}

void ns2__DateQualifiers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__DateQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DateQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DateQualifiers(struct soap *soap, const char *tag, int id, const ns2__DateQualifiers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DateQualifiers), type))
		return soap->error;
	if (soap_out_ns2__DateFractions(soap, "ns2:DateFractions", -1, &(a->ns2__DateQualifiers::DateFractions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DateQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DateQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DateQualifiers * SOAP_FMAC4 soap_in_ns2__DateQualifiers(struct soap *soap, const char *tag, ns2__DateQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DateQualifiers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DateQualifiers, sizeof(ns2__DateQualifiers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DateQualifiers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DateQualifiers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DateFractions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateFractions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__DateFractions(soap, "ns2:DateFractions", &(a->ns2__DateQualifiers::DateFractions), "ns2:DateFractions"))
				{	soap_flag_DateFractions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DateQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DateQualifiers, 0, sizeof(ns2__DateQualifiers), 0, soap_copy_ns2__DateQualifiers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateFractions1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DateQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DateQualifiers);
	if (this->soap_out(soap, tag?tag:"ns2:DateQualifiers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DateQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DateQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DateQualifiers * SOAP_FMAC4 soap_get_ns2__DateQualifiers(struct soap *soap, ns2__DateQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DateQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DateQualifiers * SOAP_FMAC2 soap_instantiate_ns2__DateQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DateQualifiers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DateQualifiers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DateQualifiers);
		if (size)
			*size = sizeof(ns2__DateQualifiers);
		((ns2__DateQualifiers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__DateQualifiers, n);
		if (size)
			*size = n * sizeof(ns2__DateQualifiers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__DateQualifiers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__DateQualifiers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DateQualifiers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DateQualifiers %p -> %p\n", q, p));
	*(ns2__DateQualifiers*)p = *(ns2__DateQualifiers*)q;
}

void ns2__DataFillErrors::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__DataFillError(soap, &this->ns2__DataFillErrors::item);
	/* transient soap skipped */
}

void ns2__DataFillErrors::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__DataFillError(soap, &this->ns2__DataFillErrors::item);
	/* transient soap skipped */
#endif
}

int ns2__DataFillErrors::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataFillErrors(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataFillErrors(struct soap *soap, const char *tag, int id, const ns2__DataFillErrors *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataFillErrors), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DataFillError(soap, "ns2:item", -1, &(a->ns2__DataFillErrors::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DataFillErrors::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataFillErrors(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataFillErrors * SOAP_FMAC4 soap_in_ns2__DataFillErrors(struct soap *soap, const char *tag, ns2__DataFillErrors *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataFillErrors *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataFillErrors, sizeof(ns2__DataFillErrors), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataFillErrors)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataFillErrors *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DataFillError(soap, "ns2:item", &(a->ns2__DataFillErrors::item), "ns2:DataFillError"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataFillErrors *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataFillErrors, 0, sizeof(ns2__DataFillErrors), 0, soap_copy_ns2__DataFillErrors);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__DataFillErrors::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataFillErrors);
	if (this->soap_out(soap, tag?tag:"ns2:DataFillErrors", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataFillErrors::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataFillErrors(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataFillErrors * SOAP_FMAC4 soap_get_ns2__DataFillErrors(struct soap *soap, ns2__DataFillErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataFillErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataFillErrors * SOAP_FMAC2 soap_instantiate_ns2__DataFillErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataFillErrors(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataFillErrors, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataFillErrors);
		if (size)
			*size = sizeof(ns2__DataFillErrors);
		((ns2__DataFillErrors*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__DataFillErrors, n);
		if (size)
			*size = n * sizeof(ns2__DataFillErrors);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__DataFillErrors*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__DataFillErrors*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataFillErrors(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataFillErrors %p -> %p\n", q, p));
	*(ns2__DataFillErrors*)p = *(ns2__DataFillErrors*)q;
}

void ns2__DataFillError::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__DataFillError::Data);
	soap_default_std__string(soap, &this->ns2__DataFillError::DataDescr);
	soap_default_std__string(soap, &this->ns2__DataFillError::Text);
	soap_default_ns2__FillCheckErrorStatus(soap, &this->ns2__DataFillError::Status);
	/* transient soap skipped */
}

void ns2__DataFillError::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__DataFillError::Data, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DataFillError::Data);
	soap_embedded(soap, &this->ns2__DataFillError::DataDescr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DataFillError::DataDescr);
	soap_embedded(soap, &this->ns2__DataFillError::Text, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DataFillError::Text);
	/* transient soap skipped */
#endif
}

int ns2__DataFillError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DataFillError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataFillError(struct soap *soap, const char *tag, int id, const ns2__DataFillError *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataFillError), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Data", -1, &(a->ns2__DataFillError::Data), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:DataDescr", -1, &(a->ns2__DataFillError::DataDescr), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Text", -1, &(a->ns2__DataFillError::Text), ""))
		return soap->error;
	if (soap_out_ns2__FillCheckErrorStatus(soap, "ns2:Status", -1, &(a->ns2__DataFillError::Status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DataFillError::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DataFillError(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DataFillError * SOAP_FMAC4 soap_in_ns2__DataFillError(struct soap *soap, const char *tag, ns2__DataFillError *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DataFillError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataFillError, sizeof(ns2__DataFillError), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DataFillError)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DataFillError *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_DataDescr1 = 1;
	size_t soap_flag_Text1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Data", &(a->ns2__DataFillError::Data), "xsd:string"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_DataDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:DataDescr", &(a->ns2__DataFillError::DataDescr), "xsd:string"))
				{	soap_flag_DataDescr1--;
					continue;
				}
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Text", &(a->ns2__DataFillError::Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__FillCheckErrorStatus(soap, "ns2:Status", &(a->ns2__DataFillError::Status), "ns2:FillCheckErrorStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DataFillError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataFillError, 0, sizeof(ns2__DataFillError), 0, soap_copy_ns2__DataFillError);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0 || soap_flag_DataDescr1 > 0 || soap_flag_Text1 > 0 || soap_flag_Status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DataFillError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DataFillError);
	if (this->soap_out(soap, tag?tag:"ns2:DataFillError", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DataFillError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DataFillError(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DataFillError * SOAP_FMAC4 soap_get_ns2__DataFillError(struct soap *soap, ns2__DataFillError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataFillError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DataFillError * SOAP_FMAC2 soap_instantiate_ns2__DataFillError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DataFillError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DataFillError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DataFillError);
		if (size)
			*size = sizeof(ns2__DataFillError);
		((ns2__DataFillError*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__DataFillError, n);
		if (size)
			*size = n * sizeof(ns2__DataFillError);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__DataFillError*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__DataFillError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DataFillError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DataFillError %p -> %p\n", q, p));
	*(ns2__DataFillError*)p = *(ns2__DataFillError*)q;
}

void ns2__BinaryDataQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns2__BinaryDataQualifiers::Length);
	soap_default_ns2__AllowedLength(soap, &this->ns2__BinaryDataQualifiers::AllowedLength);
	/* transient soap skipped */
}

void ns2__BinaryDataQualifiers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__BinaryDataQualifiers::Length, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns2__BinaryDataQualifiers::Length);
	/* transient soap skipped */
#endif
}

int ns2__BinaryDataQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BinaryDataQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BinaryDataQualifiers(struct soap *soap, const char *tag, int id, const ns2__BinaryDataQualifiers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BinaryDataQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns2:Length", -1, &(a->ns2__BinaryDataQualifiers::Length), ""))
		return soap->error;
	if (soap_out_ns2__AllowedLength(soap, "ns2:AllowedLength", -1, &(a->ns2__BinaryDataQualifiers::AllowedLength), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__BinaryDataQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BinaryDataQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BinaryDataQualifiers * SOAP_FMAC4 soap_in_ns2__BinaryDataQualifiers(struct soap *soap, const char *tag, ns2__BinaryDataQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BinaryDataQualifiers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BinaryDataQualifiers, sizeof(ns2__BinaryDataQualifiers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__BinaryDataQualifiers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__BinaryDataQualifiers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Length1 = 1;
	size_t soap_flag_AllowedLength1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns2:Length", &(a->ns2__BinaryDataQualifiers::Length), "xsd:decimal"))
				{	soap_flag_Length1--;
					continue;
				}
			if (soap_flag_AllowedLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AllowedLength(soap, "ns2:AllowedLength", &(a->ns2__BinaryDataQualifiers::AllowedLength), "ns2:AllowedLength"))
				{	soap_flag_AllowedLength1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BinaryDataQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BinaryDataQualifiers, 0, sizeof(ns2__BinaryDataQualifiers), 0, soap_copy_ns2__BinaryDataQualifiers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Length1 > 0 || soap_flag_AllowedLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__BinaryDataQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__BinaryDataQualifiers);
	if (this->soap_out(soap, tag?tag:"ns2:BinaryDataQualifiers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BinaryDataQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BinaryDataQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BinaryDataQualifiers * SOAP_FMAC4 soap_get_ns2__BinaryDataQualifiers(struct soap *soap, ns2__BinaryDataQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BinaryDataQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__BinaryDataQualifiers * SOAP_FMAC2 soap_instantiate_ns2__BinaryDataQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BinaryDataQualifiers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__BinaryDataQualifiers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__BinaryDataQualifiers);
		if (size)
			*size = sizeof(ns2__BinaryDataQualifiers);
		((ns2__BinaryDataQualifiers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__BinaryDataQualifiers, n);
		if (size)
			*size = n * sizeof(ns2__BinaryDataQualifiers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__BinaryDataQualifiers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__BinaryDataQualifiers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__BinaryDataQualifiers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__BinaryDataQualifiers %p -> %p\n", q, p));
	*(ns2__BinaryDataQualifiers*)p = *(ns2__BinaryDataQualifiers*)q;
}

void ns2__Array::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__Array::Value);
	/* transient soap skipped */
}

void ns2__Array::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__Array::Value);
	/* transient soap skipped */
#endif
}

int ns2__Array::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Array(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Array(struct soap *soap, const char *tag, int id, const ns2__Array *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Array), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:Value", -1, &(a->ns2__Array::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Array::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Array(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Array * SOAP_FMAC4 soap_in_ns2__Array(struct soap *soap, const char *tag, ns2__Array *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Array *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Array, sizeof(ns2__Array), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Array)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Array *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:Value", &(a->ns2__Array::Value), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Array *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Array, 0, sizeof(ns2__Array), 0, soap_copy_ns2__Array);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__Array::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Array);
	if (this->soap_out(soap, tag?tag:"ns2:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Array::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Array(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Array * SOAP_FMAC4 soap_get_ns2__Array(struct soap *soap, ns2__Array *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Array(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Array * SOAP_FMAC2 soap_instantiate_ns2__Array(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Array(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Array, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Array);
		if (size)
			*size = sizeof(ns2__Array);
		((ns2__Array*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Array, n);
		if (size)
			*size = n * sizeof(ns2__Array);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Array*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Array*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Array(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Array %p -> %p\n", q, p));
	*(ns2__Array*)p = *(ns2__Array*)q;
}

void _ns1__QueryUniversalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QueryUniversalResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1__QueryUniversalResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1__QueryUniversalResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1__QueryUniversalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryUniversalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryUniversalResponse(struct soap *soap, const char *tag, int id, const _ns1__QueryUniversalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryUniversalResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (soap_out_PointerTons2__ValueTable(soap, "ns1:return", -1, &(a->_ns1__QueryUniversalResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryUniversalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryUniversalResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryUniversalResponse * SOAP_FMAC4 soap_in__ns1__QueryUniversalResponse(struct soap *soap, const char *tag, _ns1__QueryUniversalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryUniversalResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryUniversalResponse, sizeof(_ns1__QueryUniversalResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__QueryUniversalResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__QueryUniversalResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "ns1:return", &(a->_ns1__QueryUniversalResponse::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryUniversalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryUniversalResponse, 0, sizeof(_ns1__QueryUniversalResponse), 0, soap_copy__ns1__QueryUniversalResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__QueryUniversalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__QueryUniversalResponse);
	if (this->soap_out(soap, tag?tag:"ns1:QueryUniversalResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryUniversalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryUniversalResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryUniversalResponse * SOAP_FMAC4 soap_get__ns1__QueryUniversalResponse(struct soap *soap, _ns1__QueryUniversalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryUniversalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__QueryUniversalResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryUniversalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryUniversalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__QueryUniversalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__QueryUniversalResponse);
		if (size)
			*size = sizeof(_ns1__QueryUniversalResponse);
		((_ns1__QueryUniversalResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__QueryUniversalResponse, n);
		if (size)
			*size = n * sizeof(_ns1__QueryUniversalResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__QueryUniversalResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__QueryUniversalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__QueryUniversalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__QueryUniversalResponse %p -> %p\n", q, p));
	*(_ns1__QueryUniversalResponse*)p = *(_ns1__QueryUniversalResponse*)q;
}

void _ns1__QueryUniversal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QueryUniversal::SystemExpression = NULL;
	/* transient soap skipped */
}

void _ns1__QueryUniversal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__QueryUniversal::SystemExpression);
	/* transient soap skipped */
#endif
}

int _ns1__QueryUniversal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryUniversal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryUniversal(struct soap *soap, const char *tag, int id, const _ns1__QueryUniversal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryUniversal), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:SystemExpression", -1, &(a->_ns1__QueryUniversal::SystemExpression), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryUniversal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryUniversal(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryUniversal * SOAP_FMAC4 soap_in__ns1__QueryUniversal(struct soap *soap, const char *tag, _ns1__QueryUniversal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryUniversal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryUniversal, sizeof(_ns1__QueryUniversal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__QueryUniversal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__QueryUniversal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SystemExpression1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemExpression1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:SystemExpression", &(a->_ns1__QueryUniversal::SystemExpression), "xsd:string"))
				{	soap_flag_SystemExpression1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryUniversal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryUniversal, 0, sizeof(_ns1__QueryUniversal), 0, soap_copy__ns1__QueryUniversal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__QueryUniversal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__QueryUniversal);
	if (this->soap_out(soap, tag?tag:"ns1:QueryUniversal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryUniversal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryUniversal(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryUniversal * SOAP_FMAC4 soap_get__ns1__QueryUniversal(struct soap *soap, _ns1__QueryUniversal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryUniversal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__QueryUniversal * SOAP_FMAC2 soap_instantiate__ns1__QueryUniversal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryUniversal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__QueryUniversal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__QueryUniversal);
		if (size)
			*size = sizeof(_ns1__QueryUniversal);
		((_ns1__QueryUniversal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__QueryUniversal, n);
		if (size)
			*size = n * sizeof(_ns1__QueryUniversal);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__QueryUniversal*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__QueryUniversal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__QueryUniversal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__QueryUniversal %p -> %p\n", q, p));
	*(_ns1__QueryUniversal*)p = *(_ns1__QueryUniversal*)q;
}

void _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, int id, const _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "return", -1, &(a->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC4 soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "return", &(a->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, 0, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response), 0, soap_copy__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
	if (this->soap_out(soap, tag?tag:"ns1:ЗаписатьДанныеResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC4 soap_get__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC2 soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
		if (size)
			*size = sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
		((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response %p -> %p\n", q, p));
	*(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p = *(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)q;
}

void _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::_x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x0430 = NULL;
	/* transient soap skipped */
}

void _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::_x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x0430);
	/* transient soap skipped */
#endif
}

int _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, int id, const _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ДанныеОбъекта", -1, &(a->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::_x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC4 soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x04301 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ДанныеОбъекта", &(a->_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::_x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x0430), "xsd:string"))
				{	soap_flag__x0414_x0430_x043d_x043d_x044b_x0435_x041e_x0431_x044a_x0435_x043a_x0442_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, 0, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435), 0, soap_copy__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
	if (this->soap_out(soap, tag?tag:"ns1:ЗаписатьДанные", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC4 soap_get__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC2 soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
		if (size)
			*size = sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
		((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, n);
		if (size)
			*size = n * sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 %p -> %p\n", q, p));
	*(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p = *(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)q;
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, int id, const _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC4 soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, 0, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse), 0, soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ЦеныНоменклатурыПоПериодамResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC4 soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC2 soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
		if (size)
			*size = sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, n);
		if (size)
			*size = n * sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse %p -> %p\n", q, p));
	*(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p = *(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)q;
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041f_x0435_x0440_x0438_x043e_x0434_x044b = NULL;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430 = NULL;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x0422_x0438_x043f_x044b_x0426_x0435_x043d = NULL;
	/* transient soap skipped */
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueListType(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041f_x0435_x0440_x0438_x043e_x0434_x044b);
	soap_serialize_PointerTons2__ValueListType(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430);
	soap_serialize_PointerTons2__ValueListType(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x0422_x0438_x043f_x044b_x0426_x0435_x043d);
	/* transient soap skipped */
#endif
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, int id, const _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "Периоды", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041f_x0435_x0440_x0438_x043e_x0434_x044b), ""))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "Номенклатура", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), ""))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "ТипыЦен", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x0422_x0438_x043f_x044b_x0426_x0435_x043d), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC4 soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x041f_x0435_x0440_x0438_x043e_x0434_x044b1 = 1;
	size_t soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 = 1;
	size_t soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x041f_x0435_x0440_x0438_x043e_x0434_x044b1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "Периоды", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041f_x0435_x0440_x0438_x043e_x0434_x044b), "ns2:ValueListType"))
				{	soap_flag__x041f_x0435_x0440_x0438_x043e_x0434_x044b1--;
					continue;
				}
			if (soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "Номенклатура", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), "ns2:ValueListType"))
				{	soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301--;
					continue;
				}
			if (soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "ТипыЦен", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::_x0422_x0438_x043f_x044b_x0426_x0435_x043d), "ns2:ValueListType"))
				{	soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, 0, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c), 0, soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
	if (this->soap_out(soap, tag?tag:"ns1:ЦеныНоменклатурыПоПериодам", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC4 soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC2 soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
		if (size)
			*size = sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, n);
		if (size)
			*size = n * sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c %p -> %p\n", q, p));
	*(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p = *(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)q;
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, int id, const _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC4 soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, 0, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response), 0, soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
	if (this->soap_out(soap, tag?tag:"ns1:ЦеныНоменклатурыПоГТДResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC4 soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC2 soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
		if (size)
			*size = sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response %p -> %p\n", q, p));
	*(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p = *(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)q;
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041f_x0435_x0440_x0438_x043e_x0434 = NULL;
	this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430 = NULL;
	/* transient soap skipped */
}

void _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041f_x0435_x0440_x0438_x043e_x0434);
	soap_serialize_PointerTons2__ValueListType(soap, &this->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430);
	/* transient soap skipped */
#endif
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, int id, const _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "Период", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041f_x0435_x0440_x0438_x043e_x0434), ""))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "Номенклатура", -1, &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC4 soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x041f_x0435_x0440_x0438_x043e_x04341 = 1;
	size_t soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x041f_x0435_x0440_x0438_x043e_x04341 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "Период", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041f_x0435_x0440_x0438_x043e_x0434), "xsd:dateTime"))
				{	soap_flag__x041f_x0435_x0440_x0438_x043e_x04341--;
					continue;
				}
			if (soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "Номенклатура", &(a->_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), "ns2:ValueListType"))
				{	soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, 0, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414), 0, soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
	if (this->soap_out(soap, tag?tag:"ns1:ЦеныНоменклатурыПоГТД", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC4 soap_get__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC2 soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
		if (size)
			*size = sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
		((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, n);
		if (size)
			*size = n * sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 %p -> %p\n", q, p));
	*(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p = *(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)q;
}

void _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTree(soap, &this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTree(soap, "return", -1, &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTree(soap, "return", &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_), "ns2:ValueTree"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, 0, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0, soap_copy__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (this->soap_out(soap, tag?tag:"ns1:РасширенныйЗапросResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p = *(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)q;
}

void _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435 = NULL;
	this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430 = NULL;
	/* transient soap skipped */
}

void _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435);
	soap_serialize_PointerTostd__string(soap, &this->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430);
	/* transient soap skipped */
#endif
}

int _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "СистемноеВыражение", -1, &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "НаименованиеЗапроса", -1, &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351 = 1;
	size_t soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "СистемноеВыражение", &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435), "xsd:string"))
				{	soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351--;
					continue;
				}
			if (soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "НаименованиеЗапроса", &(a->_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430), "xsd:string"))
				{	soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, 0, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0, soap_copy__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (this->soap_out(soap, tag?tag:"ns1:РасширенныйЗапрос", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p = *(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)q;
}

void _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, 0, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0, soap_copy__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (this->soap_out(soap, tag?tag:"ns1:УниверсальныйЗапросResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p = *(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)q;
}

void _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435 = NULL;
	this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430 = NULL;
	/* transient soap skipped */
}

void _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435);
	soap_serialize_PointerTostd__string(soap, &this->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430);
	/* transient soap skipped */
#endif
}

int _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "СистемноеВыражение", -1, &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "НаименованиеЗапроса", -1, &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351 = 1;
	size_t soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "СистемноеВыражение", &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x0435), "xsd:string"))
				{	soap_flag__x0421_x0438_x0441_x0442_x0435_x043c_x043d_x043e_x0435_x0412_x044b_x0440_x0430_x0436_x0435_x043d_x0438_x04351--;
					continue;
				}
			if (soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "НаименованиеЗапроса", &(a->_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::_x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x0430), "xsd:string"))
				{	soap_flag__x041d_x0430_x0438_x043c_x0435_x043d_x043e_x0432_x0430_x043d_x0438_x0435_x0417_x0430_x043f_x0440_x043e_x0441_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, 0, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0, soap_copy__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (this->soap_out(soap, tag?tag:"ns1:УниверсальныйЗапрос", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p = *(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)q;
}

void _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::return_);
	/* transient soap skipped */
}

void _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, int id, const _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC4 soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, 0, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response), 0, soap_copy__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
	if (this->soap_out(soap, tag?tag:"ns1:ТоварыВПутиResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC4 soap_get__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC2 soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
		if (size)
			*size = sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
		((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response %p -> %p\n", q, p));
	*(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p = *(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)q;
}

void _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430);
	soap_default_time(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f);
	/* transient soap skipped */
}

void _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430, SOAP_TYPE_time);
	soap_embedded(soap, &this->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f, SOAP_TYPE_time);
	/* transient soap skipped */
#endif
}

int _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, int id, const _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438), type))
		return soap->error;
	if (soap_out_time(soap, "ДатаНачала", -1, &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), ""))
		return soap->error;
	if (soap_out_time(soap, "ДатаОкончания", -1, &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC4 soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 = 1;
	size_t soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаНачала", &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301--;
					continue;
				}
			if (soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаОкончания", &(a->_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, 0, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438), 0, soap_copy__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 > 0 || soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
	if (this->soap_out(soap, tag?tag:"ns1:ТоварыВПути", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC4 soap_get__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC2 soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
		if (size)
			*size = sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
		((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, n);
		if (size)
			*size = n * sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 %p -> %p\n", q, p));
	*(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p = *(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)q;
}

void _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
}

void _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, 0, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0, soap_copy__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (this->soap_out(soap, tag?tag:"ns1:РасчитатьАномальныйСпросResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p = *(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)q;
}

void _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x0430);
	/* transient soap skipped */
}

void _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x0430);
	/* transient soap skipped */
#endif
}

int _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), type))
		return soap->error;
	if (soap_out_xsd__date(soap, "ДатаОтсчета", -1, &(a->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x04301 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "ДатаОтсчета", &(a->_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x0430), "xsd:date"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, 0, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0, soap_copy__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x0414_x0430_x0442_x0430_x041e_x0442_x0441_x0447_x0435_x0442_x04301 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (this->soap_out(soap, tag?tag:"ns1:РасчитатьАномальныйСпрос", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p = *(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)q;
}

void _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::return_);
	/* transient soap skipped */
}

void _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, int id, const _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC4 soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, 0, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response), 0, soap_copy__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
	if (this->soap_out(soap, tag?tag:"ns1:ПродажиResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC4 soap_get__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC2 soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
		if (size)
			*size = sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
		((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response %p -> %p\n", q, p));
	*(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p = *(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)q;
}

void _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430);
	soap_default_time(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f);
	/* transient soap skipped */
}

void _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430, SOAP_TYPE_time);
	soap_embedded(soap, &this->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f, SOAP_TYPE_time);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, int id, const _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438), type))
		return soap->error;
	if (soap_out_time(soap, "ДатаНачала", -1, &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), ""))
		return soap->error;
	if (soap_out_time(soap, "ДатаОкончания", -1, &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC4 soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 = 1;
	size_t soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаНачала", &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301--;
					continue;
				}
			if (soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаОкончания", &(a->_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, 0, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438), 0, soap_copy__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 > 0 || soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
	if (this->soap_out(soap, tag?tag:"ns1:Продажи", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC4 soap_get__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC2 soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
		if (size)
			*size = sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
		((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 %p -> %p\n", q, p));
	*(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p = *(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)q;
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, int id, const _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC4 soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, 0, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse), 0, soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ПолучитьЦеныНоменклатурыResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC4 soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC2 soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
		if (size)
			*size = sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse %p -> %p\n", q, p));
	*(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p = *(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)q;
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430 = NULL;
	this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x0422_x0438_x043f_x044b_x0426_x0435_x043d = NULL;
	/* transient soap skipped */
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueListType(soap, &this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430);
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x0422_x0438_x043f_x044b_x0426_x0435_x043d);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, int id, const _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueListType(soap, "Номенклатура", -1, &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), ""))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "ТипыЦен", -1, &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x0422_x0438_x043f_x044b_x0426_x0435_x043d), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC4 soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 = 1;
	size_t soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueListType(soap, "Номенклатура", &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x0430), "ns2:ValueListType"))
				{	soap_flag__x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x04301--;
					continue;
				}
			if (soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "ТипыЦен", &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::_x0422_x0438_x043f_x044b_x0426_x0435_x043d), "ns2:ValueTable"))
				{	soap_flag__x0422_x0438_x043f_x044b_x0426_x0435_x043d1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, 0, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b), 0, soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
	if (this->soap_out(soap, tag?tag:"ns1:ПолучитьЦеныНоменклатуры", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC4 soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC2 soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
		if (size)
			*size = sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b %p -> %p\n", q, p));
	*(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p = *(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)q;
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, int id, const _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC4 soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, 0, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response), 0, soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
	if (this->soap_out(soap, tag?tag:"ns1:ПолучитьКурсыВалютResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC4 soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC2 soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
		if (size)
			*size = sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response %p -> %p\n", q, p));
	*(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p = *(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)q;
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::_x041f_x0435_x0440_x0438_x043e_x0434 = NULL;
	/* transient soap skipped */
}

void _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::_x041f_x0435_x0440_x0438_x043e_x0434);
	/* transient soap skipped */
#endif
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, int id, const _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "Период", -1, &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::_x041f_x0435_x0440_x0438_x043e_x0434), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC4 soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x041f_x0435_x0440_x0438_x043e_x04341 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x041f_x0435_x0440_x0438_x043e_x04341 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "Период", &(a->_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::_x041f_x0435_x0440_x0438_x043e_x0434), "xsd:dateTime"))
				{	soap_flag__x041f_x0435_x0440_x0438_x043e_x04341--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, 0, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442), 0, soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
	if (this->soap_out(soap, tag?tag:"ns1:ПолучитьКурсыВалют", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC4 soap_get__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC2 soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
		if (size)
			*size = sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
		((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, n);
		if (size)
			*size = n * sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 %p -> %p\n", q, p));
	*(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p = *(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)q;
}

void _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::return_);
	/* transient soap skipped */
}

void _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, int id, const _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC4 soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, 0, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response), 0, soap_copy__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
	if (this->soap_out(soap, tag?tag:"ns1:ОстаткиResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC4 soap_get__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC2 soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
		if (size)
			*size = sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
		((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, n);
		if (size)
			*size = n * sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response %p -> %p\n", q, p));
	*(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p = *(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)q;
}

void _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x0432);
	soap_default_bool(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x0432);
	/* transient soap skipped */
}

void _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x0432);
	soap_embedded(soap, &this->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x0432, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, int id, const _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438), type))
		return soap->error;
	if (soap_out_xsd__date(soap, "ДатаОстатков", -1, &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x0432), ""))
		return soap->error;
	if (soap_out_bool(soap, "УчитыватьСтатусыДокументов", -1, &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x0432), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC4 soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x04321 = 1;
	size_t soap_flag__x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x04321 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x04321 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "ДатаОстатков", &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x0432), "xsd:date"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x04321--;
					continue;
				}
			if (soap_flag__x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x04321 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "УчитыватьСтатусыДокументов", &(a->_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::_x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x0432), "xsd:boolean"))
				{	soap_flag__x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x04321--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, 0, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438), 0, soap_copy__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x0414_x0430_x0442_x0430_x041e_x0441_x0442_x0430_x0442_x043a_x043e_x04321 > 0 || soap_flag__x0423_x0447_x0438_x0442_x044b_x0432_x0430_x0442_x044c_x0421_x0442_x0430_x0442_x0443_x0441_x044b_x0414_x043e_x043a_x0443_x043c_x0435_x043d_x0442_x043e_x04321 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
	if (this->soap_out(soap, tag?tag:"ns1:Остатки", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC4 soap_get__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC2 soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
		if (size)
			*size = sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
		((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, n);
		if (size)
			*size = n * sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 %p -> %p\n", q, p));
	*(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p = *(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)q;
}

void _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
}

void _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, 0, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0, soap_copy__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (this->soap_out(soap, tag?tag:"ns1:НеВыполненныйСпросResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p = *(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)q;
}

void _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430);
	soap_default_time(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f);
	soap_default_bool(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x0438);
	/* transient soap skipped */
}

void _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430, SOAP_TYPE_time);
	soap_embedded(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f, SOAP_TYPE_time);
	soap_embedded(soap, &this->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x0438, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), type))
		return soap->error;
	if (soap_out_time(soap, "ДатаНачала", -1, &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), ""))
		return soap->error;
	if (soap_out_time(soap, "ДатаОкончания", -1, &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), ""))
		return soap->error;
	if (soap_out_bool(soap, "ТолькоСети", -1, &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x0438), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 = 1;
	size_t soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 = 1;
	size_t soap_flag__x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x04381 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаНачала", &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x0430), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301--;
					continue;
				}
			if (soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ДатаОкончания", &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f), "xsd:dateTime"))
				{	soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1--;
					continue;
				}
			if (soap_flag__x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x04381 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ТолькоСети", &(a->_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::_x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x0438), "xsd:boolean"))
				{	soap_flag__x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x04381--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, 0, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0, soap_copy__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x0414_x0430_x0442_x0430_x041d_x0430_x0447_x0430_x043b_x04301 > 0 || soap_flag__x0414_x0430_x0442_x0430_x041e_x043a_x043e_x043d_x0447_x0430_x043d_x0438_x044f1 > 0 || soap_flag__x0422_x043e_x043b_x044c_x043a_x043e_x0421_x0435_x0442_x04381 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (this->soap_out(soap, tag?tag:"ns1:НеВыполненныйСпрос", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p = *(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)q;
}

void _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, int id, const _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__ValueTable(soap, "return", -1, &(a->_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC4 soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "return", &(a->_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, 0, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse), 0, soap_copy__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ИнформационныеБазыResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC4 soap_get__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC2 soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
		if (size)
			*size = sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
		((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, n);
		if (size)
			*size = n * sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse %p -> %p\n", q, p));
	*(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p = *(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)q;
}

void _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, int id, const _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC4 soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, 0, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b), 0, soap_copy__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
	if (this->soap_out(soap, tag?tag:"ns1:ИнформационныеБазы", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC4 soap_get__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC2 soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
		if (size)
			*size = sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
		((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, n);
		if (size)
			*size = n * sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b %p -> %p\n", q, p));
	*(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p = *(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)q;
}

void _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::return_);
	/* transient soap skipped */
}

void _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, int id, const _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC4 soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, 0, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse), 0, soap_copy__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ДниОтсутствияResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC4 soap_get__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC2 soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
		if (size)
			*size = sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
		((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, n);
		if (size)
			*size = n * sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse %p -> %p\n", q, p));
	*(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p = *(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)q;
}

void _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430);
	soap_default_time(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x0430);
	/* transient soap skipped */
}

void _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430, SOAP_TYPE_time);
	soap_embedded(soap, &this->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x0430, SOAP_TYPE_time);
	/* transient soap skipped */
#endif
}

int _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, int id, const _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f), type))
		return soap->error;
	if (soap_out_time(soap, "НачалоПериода", -1, &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430), ""))
		return soap->error;
	if (soap_out_time(soap, "КонецПериода", -1, &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x0430), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, this, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC4 soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag__x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x04301 = 1;
	size_t soap_flag__x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x04301 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "НачалоПериода", &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430), "xsd:dateTime"))
				{	soap_flag__x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x04301--;
					continue;
				}
			if (soap_flag__x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x04301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "КонецПериода", &(a->_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::_x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x0430), "xsd:dateTime"))
				{	soap_flag__x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x04301--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, 0, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f), 0, soap_copy__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__x041d_x0430_x0447_x0430_x043b_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x04301 > 0 || soap_flag__x041a_x043e_x043d_x0435_x0446_x041f_x0435_x0440_x0438_x043e_x0434_x04301 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
	if (this->soap_out(soap, tag?tag:"ns1:ДниОтсутствия", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, this, tag, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC4 soap_get__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC2 soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
		if (size)
			*size = sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
		((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, n);
		if (size)
			*size = n * sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f %p -> %p\n", q, p));
	*(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p = *(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)q;
}

void _ns1__GetStructureInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStructureInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1__GetStructureInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Object(soap, &this->_ns1__GetStructureInfoResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1__GetStructureInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStructureInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStructureInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStructureInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStructureInfoResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (a->_ns1__GetStructureInfoResponse::return_)
	{	if (soap_out_PointerTons1__Object(soap, "ns1:return", -1, &a->_ns1__GetStructureInfoResponse::return_, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:return"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStructureInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStructureInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStructureInfoResponse * SOAP_FMAC4 soap_in__ns1__GetStructureInfoResponse(struct soap *soap, const char *tag, _ns1__GetStructureInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStructureInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStructureInfoResponse, sizeof(_ns1__GetStructureInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStructureInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStructureInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Object(soap, "ns1:return", &(a->_ns1__GetStructureInfoResponse::return_), "ns1:Object"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStructureInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStructureInfoResponse, 0, sizeof(_ns1__GetStructureInfoResponse), 0, soap_copy__ns1__GetStructureInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetStructureInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStructureInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetStructureInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStructureInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStructureInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStructureInfoResponse * SOAP_FMAC4 soap_get__ns1__GetStructureInfoResponse(struct soap *soap, _ns1__GetStructureInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStructureInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStructureInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStructureInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStructureInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStructureInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStructureInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetStructureInfoResponse);
		((_ns1__GetStructureInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetStructureInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetStructureInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetStructureInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetStructureInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStructureInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStructureInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetStructureInfoResponse*)p = *(_ns1__GetStructureInfoResponse*)q;
}

void _ns1__GetStructureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStructureInfo::TableName = NULL;
	/* transient soap skipped */
}

void _ns1__GetStructureInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetStructureInfo::TableName);
	/* transient soap skipped */
#endif
}

int _ns1__GetStructureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStructureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStructureInfo(struct soap *soap, const char *tag, int id, const _ns1__GetStructureInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStructureInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TableName", -1, &(a->_ns1__GetStructureInfo::TableName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStructureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStructureInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStructureInfo * SOAP_FMAC4 soap_in__ns1__GetStructureInfo(struct soap *soap, const char *tag, _ns1__GetStructureInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStructureInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStructureInfo, sizeof(_ns1__GetStructureInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStructureInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStructureInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TableName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:TableName", &(a->_ns1__GetStructureInfo::TableName), "xsd:string"))
				{	soap_flag_TableName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStructureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStructureInfo, 0, sizeof(_ns1__GetStructureInfo), 0, soap_copy__ns1__GetStructureInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetStructureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStructureInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetStructureInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStructureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStructureInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStructureInfo * SOAP_FMAC4 soap_get__ns1__GetStructureInfo(struct soap *soap, _ns1__GetStructureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStructureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetStructureInfo * SOAP_FMAC2 soap_instantiate__ns1__GetStructureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStructureInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStructureInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetStructureInfo);
		if (size)
			*size = sizeof(_ns1__GetStructureInfo);
		((_ns1__GetStructureInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetStructureInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetStructureInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetStructureInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetStructureInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStructureInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStructureInfo %p -> %p\n", q, p));
	*(_ns1__GetStructureInfo*)p = *(_ns1__GetStructureInfo*)q;
}

void _ns1__GetAmountGoodsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAmountGoodsResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns1__GetAmountGoodsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ValueTable(soap, &this->_ns1__GetAmountGoodsResponse::return_);
	/* transient soap skipped */
#endif
}

int _ns1__GetAmountGoodsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAmountGoodsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAmountGoodsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAmountGoodsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAmountGoodsResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (a->_ns1__GetAmountGoodsResponse::return_)
	{	if (soap_out_PointerTons2__ValueTable(soap, "ns1:return", -1, &a->_ns1__GetAmountGoodsResponse::return_, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:return"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAmountGoodsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAmountGoodsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAmountGoodsResponse * SOAP_FMAC4 soap_in__ns1__GetAmountGoodsResponse(struct soap *soap, const char *tag, _ns1__GetAmountGoodsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAmountGoodsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAmountGoodsResponse, sizeof(_ns1__GetAmountGoodsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAmountGoodsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAmountGoodsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValueTable(soap, "ns1:return", &(a->_ns1__GetAmountGoodsResponse::return_), "ns2:ValueTable"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAmountGoodsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAmountGoodsResponse, 0, sizeof(_ns1__GetAmountGoodsResponse), 0, soap_copy__ns1__GetAmountGoodsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetAmountGoodsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAmountGoodsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAmountGoodsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAmountGoodsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAmountGoodsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAmountGoodsResponse * SOAP_FMAC4 soap_get__ns1__GetAmountGoodsResponse(struct soap *soap, _ns1__GetAmountGoodsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAmountGoodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAmountGoodsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAmountGoodsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAmountGoodsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAmountGoodsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAmountGoodsResponse);
		if (size)
			*size = sizeof(_ns1__GetAmountGoodsResponse);
		((_ns1__GetAmountGoodsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAmountGoodsResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAmountGoodsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAmountGoodsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAmountGoodsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAmountGoodsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAmountGoodsResponse %p -> %p\n", q, p));
	*(_ns1__GetAmountGoodsResponse*)p = *(_ns1__GetAmountGoodsResponse*)q;
}

void _ns1__GetAmountGoods::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAmountGoods::Period = NULL;
	this->_ns1__GetAmountGoods::Options = NULL;
	this->_ns1__GetAmountGoods::Selections = NULL;
	/* transient soap skipped */
}

void _ns1__GetAmountGoods::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->_ns1__GetAmountGoods::Period);
	soap_serialize_PointerTons2__Structure(soap, &this->_ns1__GetAmountGoods::Options);
	soap_serialize_PointerTons2__Structure(soap, &this->_ns1__GetAmountGoods::Selections);
	/* transient soap skipped */
#endif
}

int _ns1__GetAmountGoods::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAmountGoods(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAmountGoods(struct soap *soap, const char *tag, int id, const _ns1__GetAmountGoods *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAmountGoods), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Period", -1, &(a->_ns1__GetAmountGoods::Period), ""))
		return soap->error;
	if (soap_out_PointerTons2__Structure(soap, "ns1:Options", -1, &(a->_ns1__GetAmountGoods::Options), ""))
		return soap->error;
	if (soap_out_PointerTons2__Structure(soap, "ns1:Selections", -1, &(a->_ns1__GetAmountGoods::Selections), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAmountGoods::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAmountGoods(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAmountGoods * SOAP_FMAC4 soap_in__ns1__GetAmountGoods(struct soap *soap, const char *tag, _ns1__GetAmountGoods *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAmountGoods *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAmountGoods, sizeof(_ns1__GetAmountGoods), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAmountGoods)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAmountGoods *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Period1 = 1;
	size_t soap_flag_Options1 = 1;
	size_t soap_flag_Selections1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Period1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Period", &(a->_ns1__GetAmountGoods::Period), "xsd:dateTime"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Structure(soap, "ns1:Options", &(a->_ns1__GetAmountGoods::Options), "ns2:Structure"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_Selections1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Structure(soap, "ns1:Selections", &(a->_ns1__GetAmountGoods::Selections), "ns2:Structure"))
				{	soap_flag_Selections1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAmountGoods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAmountGoods, 0, sizeof(_ns1__GetAmountGoods), 0, soap_copy__ns1__GetAmountGoods);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAmountGoods::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAmountGoods);
	if (this->soap_out(soap, tag?tag:"ns1:GetAmountGoods", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAmountGoods::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAmountGoods(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAmountGoods * SOAP_FMAC4 soap_get__ns1__GetAmountGoods(struct soap *soap, _ns1__GetAmountGoods *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAmountGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAmountGoods * SOAP_FMAC2 soap_instantiate__ns1__GetAmountGoods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAmountGoods(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAmountGoods, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAmountGoods);
		if (size)
			*size = sizeof(_ns1__GetAmountGoods);
		((_ns1__GetAmountGoods*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAmountGoods, n);
		if (size)
			*size = n * sizeof(_ns1__GetAmountGoods);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAmountGoods*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAmountGoods*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAmountGoods(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAmountGoods %p -> %p\n", q, p));
	*(_ns1__GetAmountGoods*)p = *(_ns1__GetAmountGoods*)q;
}

void ns1__Structure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Object(soap, &this->ns1__Structure::Objects);
	/* transient soap skipped */
}

void ns1__Structure::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Object(soap, &this->ns1__Structure::Objects);
	/* transient soap skipped */
#endif
}

int ns1__Structure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Structure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Structure(struct soap *soap, const char *tag, int id, const ns1__Structure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Structure), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Object(soap, "ns1:Objects", -1, &(a->ns1__Structure::Objects), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Structure::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Structure(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Structure * SOAP_FMAC4 soap_in_ns1__Structure(struct soap *soap, const char *tag, ns1__Structure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Structure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Structure, sizeof(ns1__Structure), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Structure)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Structure *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Object(soap, "ns1:Objects", &(a->ns1__Structure::Objects), "ns1:Object"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Structure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Structure, 0, sizeof(ns1__Structure), 0, soap_copy_ns1__Structure);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__Structure::Objects.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Structure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Structure);
	if (this->soap_out(soap, tag?tag:"ns1:Structure", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Structure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Structure(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Structure * SOAP_FMAC4 soap_get_ns1__Structure(struct soap *soap, ns1__Structure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Structure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Structure * SOAP_FMAC2 soap_instantiate_ns1__Structure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Structure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Structure, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Structure);
		if (size)
			*size = sizeof(ns1__Structure);
		((ns1__Structure*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Structure, n);
		if (size)
			*size = n * sizeof(ns1__Structure);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Structure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Structure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Structure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Structure %p -> %p\n", q, p));
	*(ns1__Structure*)p = *(ns1__Structure*)q;
}

void ns1__Object::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Object::StorageTableName);
	soap_default_std__string(soap, &this->ns1__Object::StorageFieldName);
	soap_default_std__string(soap, &this->ns1__Object::FieldName);
	soap_default_std__string(soap, &this->ns1__Object::Metadata);
	/* transient soap skipped */
}

void ns1__Object::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Object::StorageTableName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Object::StorageTableName);
	soap_embedded(soap, &this->ns1__Object::StorageFieldName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Object::StorageFieldName);
	soap_embedded(soap, &this->ns1__Object::FieldName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Object::FieldName);
	soap_embedded(soap, &this->ns1__Object::Metadata, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Object::Metadata);
	/* transient soap skipped */
#endif
}

int ns1__Object::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Object(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Object(struct soap *soap, const char *tag, int id, const ns1__Object *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Object), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:StorageTableName", -1, &(a->ns1__Object::StorageTableName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:StorageFieldName", -1, &(a->ns1__Object::StorageFieldName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:FieldName", -1, &(a->ns1__Object::FieldName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Metadata", -1, &(a->ns1__Object::Metadata), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Object::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Object(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Object * SOAP_FMAC4 soap_in_ns1__Object(struct soap *soap, const char *tag, ns1__Object *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Object *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Object, sizeof(ns1__Object), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Object)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Object *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StorageTableName1 = 1;
	size_t soap_flag_StorageFieldName1 = 1;
	size_t soap_flag_FieldName1 = 1;
	size_t soap_flag_Metadata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:StorageTableName", &(a->ns1__Object::StorageTableName), "xsd:string"))
				{	soap_flag_StorageTableName1--;
					continue;
				}
			if (soap_flag_StorageFieldName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:StorageFieldName", &(a->ns1__Object::StorageFieldName), "xsd:string"))
				{	soap_flag_StorageFieldName1--;
					continue;
				}
			if (soap_flag_FieldName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:FieldName", &(a->ns1__Object::FieldName), "xsd:string"))
				{	soap_flag_FieldName1--;
					continue;
				}
			if (soap_flag_Metadata1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Metadata", &(a->ns1__Object::Metadata), "xsd:string"))
				{	soap_flag_Metadata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Object, 0, sizeof(ns1__Object), 0, soap_copy_ns1__Object);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageTableName1 > 0 || soap_flag_StorageFieldName1 > 0 || soap_flag_FieldName1 > 0 || soap_flag_Metadata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Object::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Object);
	if (this->soap_out(soap, tag?tag:"ns1:Object", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Object::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Object(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Object * SOAP_FMAC4 soap_get_ns1__Object(struct soap *soap, ns1__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Object * SOAP_FMAC2 soap_instantiate_ns1__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Object);
		if (size)
			*size = sizeof(ns1__Object);
		((ns1__Object*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__Object, n);
		if (size)
			*size = n * sizeof(ns1__Object);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__Object*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__Object*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Object %p -> %p\n", q, p));
	*(ns1__Object*)p = *(ns1__Object*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__date, 0, sizeof(std::string), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NMTOKEN, 0, sizeof(std::wstring), 0, soap_copy_xsd__NMTOKEN);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryUniversal_(struct soap *soap, struct __ns1__QueryUniversal_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryUniversal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryUniversal_(struct soap *soap, const struct __ns1__QueryUniversal_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__QueryUniversal(soap, &a->ns1__QueryUniversal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryUniversal_(struct soap *soap, const char *tag, int id, const struct __ns1__QueryUniversal_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__QueryUniversal(soap, "ns1:QueryUniversal", -1, &a->ns1__QueryUniversal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryUniversal_ * SOAP_FMAC4 soap_in___ns1__QueryUniversal_(struct soap *soap, const char *tag, struct __ns1__QueryUniversal_ *a, const char *type)
{
	size_t soap_flag_ns1__QueryUniversal = 1;
	short soap_flag;
	a = (struct __ns1__QueryUniversal_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryUniversal_, sizeof(struct __ns1__QueryUniversal_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryUniversal_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryUniversal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QueryUniversal(soap, "ns1:QueryUniversal", &a->ns1__QueryUniversal, ""))
				{	soap_flag_ns1__QueryUniversal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryUniversal_(struct soap *soap, const struct __ns1__QueryUniversal_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__QueryUniversal_(soap, tag?tag:"-ns1:QueryUniversal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryUniversal_ * SOAP_FMAC4 soap_get___ns1__QueryUniversal_(struct soap *soap, struct __ns1__QueryUniversal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryUniversal_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__QueryUniversal_ * SOAP_FMAC2 soap_instantiate___ns1__QueryUniversal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryUniversal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__QueryUniversal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__QueryUniversal_);
		if (size)
			*size = sizeof(struct __ns1__QueryUniversal_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__QueryUniversal_, n);
		if (size)
			*size = n * sizeof(struct __ns1__QueryUniversal_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__QueryUniversal_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__QueryUniversal_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__QueryUniversal_ %p -> %p\n", q, p));
	*(struct __ns1__QueryUniversal_*)p = *(struct __ns1__QueryUniversal_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, const char *tag, int id, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, "ns1:ЗаписатьДанные", -1, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ * SOAP_FMAC4 soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, const char *tag, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *a, const char *type)
{
	size_t soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 = 1;
	short soap_flag;
	a = (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_, sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, "ns1:ЗаписатьДанные", &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, ""))
				{	soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(soap, tag?tag:"-ns1:ЗаписатьДанные", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ * SOAP_FMAC4 soap_get___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ * SOAP_FMAC2 soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_);
		if (size)
			*size = sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_ %p -> %p\n", q, p));
	*(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_*)p = *(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, "ns1:ЗаписатьДанныеResponse", -1, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response * SOAP_FMAC4 soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, const char *tag, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response = 1;
	short soap_flag;
	a = (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response, sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, "ns1:ЗаписатьДанныеResponse", &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, ""))
				{	soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(soap, tag?tag:"-ns1:ЗаписатьДанные-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response * SOAP_FMAC4 soap_get___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response * SOAP_FMAC2 soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response);
		if (size)
			*size = sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response %p -> %p\n", q, p));
	*(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response*)p = *(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, "ns1:ЦеныНоменклатурыПоПериодам", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, "ns1:ЦеныНоменклатурыПоПериодам", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоПериодам", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_ %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, "ns1:ЦеныНоменклатурыПоПериодамResponse", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, "ns1:ЦеныНоменклатурыПоПериодамResponse", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоПериодам-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, "ns1:ЦеныНоменклатурыПоГТД", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, "ns1:ЦеныНоменклатурыПоГТД", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоГТД", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_ %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, "ns1:ЦеныНоменклатурыПоГТДResponse", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, "ns1:ЦеныНоменклатурыПоГТДResponse", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоГТД-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:РасширенныйЗапрос", -1, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:РасширенныйЗапрос", &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, tag?tag:"-ns1:РасширенныйЗапрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p = *(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:РасширенныйЗапросResponse", -1, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:РасширенныйЗапросResponse", &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, tag?tag:"-ns1:РасширенныйЗапрос-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p = *(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, int id, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:УниверсальныйЗапрос", -1, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	size_t soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:УниверсальныйЗапрос", &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, tag?tag:"-ns1:УниверсальныйЗапрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_get___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ * SOAP_FMAC2 soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
		if (size)
			*size = sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_ %p -> %p\n", q, p));
	*(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)p = *(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:УниверсальныйЗапросResponse", -1, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:УниверсальныйЗапросResponse", &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, tag?tag:"-ns1:УниверсальныйЗапрос-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_get___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response * SOAP_FMAC2 soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
		if (size)
			*size = sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response %p -> %p\n", q, p));
	*(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)p = *(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, const char *tag, int id, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, "ns1:ТоварыВПути", -1, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ * SOAP_FMAC4 soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, const char *tag, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *a, const char *type)
{
	size_t soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_, sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, "ns1:ТоварыВПути", &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, ""))
				{	soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(soap, tag?tag:"-ns1:ТоварыВПути", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ * SOAP_FMAC4 soap_get___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ * SOAP_FMAC2 soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_);
		if (size)
			*size = sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_ %p -> %p\n", q, p));
	*(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_*)p = *(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, "ns1:ТоварыВПутиResponse", -1, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response * SOAP_FMAC4 soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, const char *tag, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response, sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, "ns1:ТоварыВПутиResponse", &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, ""))
				{	soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(soap, tag?tag:"-ns1:ТоварыВПути-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response * SOAP_FMAC4 soap_get___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response * SOAP_FMAC2 soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response);
		if (size)
			*size = sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response %p -> %p\n", q, p));
	*(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response*)p = *(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:РасчитатьАномальныйСпрос", -1, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:РасчитатьАномальныйСпрос", &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, tag?tag:"-ns1:РасчитатьАномальныйСпрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p = *(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:РасчитатьАномальныйСпросResponse", -1, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:РасчитатьАномальныйСпросResponse", &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, tag?tag:"-ns1:РасчитатьАномальныйСпрос-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p = *(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, "ns1:Продажи", -1, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ * SOAP_FMAC4 soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, const char *tag, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_, sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, "ns1:Продажи", &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, ""))
				{	soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(soap, tag?tag:"-ns1:Продажи", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ * SOAP_FMAC4 soap_get___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ * SOAP_FMAC2 soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_);
		if (size)
			*size = sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_ %p -> %p\n", q, p));
	*(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_*)p = *(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, "ns1:ПродажиResponse", -1, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response * SOAP_FMAC4 soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, const char *tag, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response, sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, "ns1:ПродажиResponse", &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, ""))
				{	soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(soap, tag?tag:"-ns1:Продажи-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response * SOAP_FMAC4 soap_get___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response * SOAP_FMAC2 soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response);
		if (size)
			*size = sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response %p -> %p\n", q, p));
	*(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response*)p = *(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, "ns1:ПолучитьЦеныНоменклатуры", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, "ns1:ПолучитьЦеныНоменклатуры", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(soap, tag?tag:"-ns1:ПолучитьЦеныНоменклатуры", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_ %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, "ns1:ПолучитьЦеныНоменклатурыResponse", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, "ns1:ПолучитьЦеныНоменклатурыResponse", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(soap, tag?tag:"-ns1:ПолучитьЦеныНоменклатуры-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, "ns1:ПолучитьКурсыВалют", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, "ns1:ПолучитьКурсыВалют", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(soap, tag?tag:"-ns1:ПолучитьКурсыВалют", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_ %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, "ns1:ПолучитьКурсыВалютResponse", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, "ns1:ПолучитьКурсыВалютResponse", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(soap, tag?tag:"-ns1:ПолучитьКурсыВалют-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, const char *tag, int id, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, "ns1:Остатки", -1, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ * SOAP_FMAC4 soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, const char *tag, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *a, const char *type)
{
	size_t soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_, sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, "ns1:Остатки", &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, ""))
				{	soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(soap, tag?tag:"-ns1:Остатки", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ * SOAP_FMAC4 soap_get___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ * SOAP_FMAC2 soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_);
		if (size)
			*size = sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_ %p -> %p\n", q, p));
	*(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_*)p = *(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, "ns1:ОстаткиResponse", -1, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response * SOAP_FMAC4 soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, const char *tag, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *a, const char *type)
{
	size_t soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response, sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, "ns1:ОстаткиResponse", &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, ""))
				{	soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(soap, tag?tag:"-ns1:Остатки-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response * SOAP_FMAC4 soap_get___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response * SOAP_FMAC2 soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response);
		if (size)
			*size = sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response %p -> %p\n", q, p));
	*(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response*)p = *(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, int id, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:НеВыполненныйСпрос", -1, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const char *tag, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *type)
{
	size_t soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:НеВыполненныйСпрос", &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, tag?tag:"-ns1:НеВыполненныйСпрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC4 soap_get___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ * SOAP_FMAC2 soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
		if (size)
			*size = sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_ %p -> %p\n", q, p));
	*(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)p = *(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:НеВыполненныйСпросResponse", -1, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const char *tag, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *type)
{
	size_t soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:НеВыполненныйСпросResponse", &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, tag?tag:"-ns1:НеВыполненныйСпрос-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC4 soap_get___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response * SOAP_FMAC2 soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
		if (size)
			*size = sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response %p -> %p\n", q, p));
	*(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)p = *(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, const char *tag, int id, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, "ns1:ИнформационныеБазы", -1, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ * SOAP_FMAC4 soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, const char *tag, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *a, const char *type)
{
	size_t soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b = 1;
	short soap_flag;
	a = (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_, sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, "ns1:ИнформационныеБазы", &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, ""))
				{	soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(soap, tag?tag:"-ns1:ИнформационныеБазы", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ * SOAP_FMAC4 soap_get___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ * SOAP_FMAC2 soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_);
		if (size)
			*size = sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_ %p -> %p\n", q, p));
	*(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_*)p = *(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, "ns1:ИнформационныеБазыResponse", -1, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response * SOAP_FMAC4 soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, const char *tag, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response, sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, "ns1:ИнформационныеБазыResponse", &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, ""))
				{	soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(soap, tag?tag:"-ns1:ИнформационныеБазы-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response * SOAP_FMAC4 soap_get___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response * SOAP_FMAC2 soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response);
		if (size)
			*size = sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response %p -> %p\n", q, p));
	*(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response*)p = *(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, const char *tag, int id, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, "ns1:ДниОтсутствия", -1, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ * SOAP_FMAC4 soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, const char *tag, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *a, const char *type)
{
	size_t soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f = 1;
	short soap_flag;
	a = (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_, sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, "ns1:ДниОтсутствия", &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, ""))
				{	soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(soap, tag?tag:"-ns1:ДниОтсутствия", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ * SOAP_FMAC4 soap_get___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ * SOAP_FMAC2 soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_);
		if (size)
			*size = sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_ %p -> %p\n", q, p));
	*(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_*)p = *(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, "ns1:ДниОтсутствияResponse", -1, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response * SOAP_FMAC4 soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, const char *tag, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *a, const char *type)
{
	size_t soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response, sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, "ns1:ДниОтсутствияResponse", &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, ""))
				{	soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(soap, tag?tag:"-ns1:ДниОтсутствия-Response", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response * SOAP_FMAC4 soap_get___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response * SOAP_FMAC2 soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response);
		if (size)
			*size = sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response %p -> %p\n", q, p));
	*(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response*)p = *(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStructureInfo_(struct soap *soap, struct __ns1__GetStructureInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStructureInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStructureInfo_(struct soap *soap, const struct __ns1__GetStructureInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStructureInfo(soap, &a->ns1__GetStructureInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStructureInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetStructureInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetStructureInfo(soap, "ns1:GetStructureInfo", -1, &a->ns1__GetStructureInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStructureInfo_ * SOAP_FMAC4 soap_in___ns1__GetStructureInfo_(struct soap *soap, const char *tag, struct __ns1__GetStructureInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetStructureInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetStructureInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStructureInfo_, sizeof(struct __ns1__GetStructureInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStructureInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStructureInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStructureInfo(soap, "ns1:GetStructureInfo", &a->ns1__GetStructureInfo, ""))
				{	soap_flag_ns1__GetStructureInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStructureInfo_(struct soap *soap, const struct __ns1__GetStructureInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetStructureInfo_(soap, tag?tag:"-ns1:GetStructureInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStructureInfo_ * SOAP_FMAC4 soap_get___ns1__GetStructureInfo_(struct soap *soap, struct __ns1__GetStructureInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStructureInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetStructureInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetStructureInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStructureInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetStructureInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetStructureInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetStructureInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetStructureInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetStructureInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetStructureInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetStructureInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetStructureInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetStructureInfo_*)p = *(struct __ns1__GetStructureInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAmountGoods_(struct soap *soap, struct __ns1__GetAmountGoods_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAmountGoods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAmountGoods_(struct soap *soap, const struct __ns1__GetAmountGoods_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAmountGoods(soap, &a->ns1__GetAmountGoods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAmountGoods_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAmountGoods_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAmountGoods(soap, "ns1:GetAmountGoods", -1, &a->ns1__GetAmountGoods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAmountGoods_ * SOAP_FMAC4 soap_in___ns1__GetAmountGoods_(struct soap *soap, const char *tag, struct __ns1__GetAmountGoods_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAmountGoods = 1;
	short soap_flag;
	a = (struct __ns1__GetAmountGoods_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAmountGoods_, sizeof(struct __ns1__GetAmountGoods_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAmountGoods_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAmountGoods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAmountGoods(soap, "ns1:GetAmountGoods", &a->ns1__GetAmountGoods, ""))
				{	soap_flag_ns1__GetAmountGoods--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAmountGoods_(struct soap *soap, const struct __ns1__GetAmountGoods_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAmountGoods_(soap, tag?tag:"-ns1:GetAmountGoods", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAmountGoods_ * SOAP_FMAC4 soap_get___ns1__GetAmountGoods_(struct soap *soap, struct __ns1__GetAmountGoods_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAmountGoods_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAmountGoods_ * SOAP_FMAC2 soap_instantiate___ns1__GetAmountGoods_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAmountGoods_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAmountGoods_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAmountGoods_);
		if (size)
			*size = sizeof(struct __ns1__GetAmountGoods_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAmountGoods_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAmountGoods_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAmountGoods_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAmountGoods_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAmountGoods_ %p -> %p\n", q, p));
	*(struct __ns1__GetAmountGoods_*)p = *(struct __ns1__GetAmountGoods_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryUniversal(struct soap *soap, struct __ns1__QueryUniversal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryUniversal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryUniversal(struct soap *soap, const struct __ns1__QueryUniversal *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__QueryUniversal(soap, &a->ns1__QueryUniversal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryUniversal(struct soap *soap, const char *tag, int id, const struct __ns1__QueryUniversal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__QueryUniversal(soap, "ns1:QueryUniversal", -1, &a->ns1__QueryUniversal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryUniversal * SOAP_FMAC4 soap_in___ns1__QueryUniversal(struct soap *soap, const char *tag, struct __ns1__QueryUniversal *a, const char *type)
{
	size_t soap_flag_ns1__QueryUniversal = 1;
	short soap_flag;
	a = (struct __ns1__QueryUniversal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryUniversal, sizeof(struct __ns1__QueryUniversal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryUniversal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryUniversal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QueryUniversal(soap, "ns1:QueryUniversal", &a->ns1__QueryUniversal, ""))
				{	soap_flag_ns1__QueryUniversal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryUniversal(struct soap *soap, const struct __ns1__QueryUniversal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__QueryUniversal(soap, tag?tag:"-ns1:QueryUniversal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryUniversal * SOAP_FMAC4 soap_get___ns1__QueryUniversal(struct soap *soap, struct __ns1__QueryUniversal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryUniversal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__QueryUniversal * SOAP_FMAC2 soap_instantiate___ns1__QueryUniversal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryUniversal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__QueryUniversal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__QueryUniversal);
		if (size)
			*size = sizeof(struct __ns1__QueryUniversal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__QueryUniversal, n);
		if (size)
			*size = n * sizeof(struct __ns1__QueryUniversal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__QueryUniversal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__QueryUniversal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__QueryUniversal %p -> %p\n", q, p));
	*(struct __ns1__QueryUniversal*)p = *(struct __ns1__QueryUniversal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, int id, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, "ns1:ЗаписатьДанные", -1, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC4 soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a, const char *type)
{
	size_t soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 = 1;
	short soap_flag;
	a = (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, "ns1:ЗаписатьДанные", &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, ""))
				{	soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag?tag:"-ns1:ЗаписатьДанные", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC4 soap_get___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 * SOAP_FMAC2 soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
		if (size)
			*size = sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 %p -> %p\n", q, p));
	*(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)p = *(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, "ns1:ЗаписатьДанныеResponse", -1, &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC4 soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a, const char *type)
{
	size_t soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response = 1;
	short soap_flag;
	a = (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, "ns1:ЗаписатьДанныеResponse", &a->ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, ""))
				{	soap_flag_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag?tag:"-ns1:ЗаписатьДанныеResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC4 soap_get___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response * SOAP_FMAC2 soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
		if (size)
			*size = sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response %p -> %p\n", q, p));
	*(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)p = *(struct __ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, "ns1:ЦеныНоменклатурыПоПериодам", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, "ns1:ЦеныНоменклатурыПоПериодам", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоПериодам", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, "ns1:ЦеныНоменклатурыПоПериодамResponse", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, "ns1:ЦеныНоменклатурыПоПериодамResponse", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоПериодамResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, "ns1:ЦеныНоменклатурыПоГТД", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, "ns1:ЦеныНоменклатурыПоГТД", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоГТД", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, "ns1:ЦеныНоменклатурыПоГТДResponse", -1, &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC4 soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a, const char *type)
{
	size_t soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response = 1;
	short soap_flag;
	a = (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, "ns1:ЦеныНоменклатурыПоГТДResponse", &a->ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, ""))
				{	soap_flag_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag?tag:"-ns1:ЦеныНоменклатурыПоГТДResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC4 soap_get___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response * SOAP_FMAC2 soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
		if (size)
			*size = sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response %p -> %p\n", q, p));
	*(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)p = *(struct __ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:РасширенныйЗапрос", -1, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:РасширенныйЗапрос", &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag?tag:"-ns1:РасширенныйЗапрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p = *(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:РасширенныйЗапросResponse", -1, &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:РасширенныйЗапросResponse", &a->ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag?tag:"-ns1:РасширенныйЗапросResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p = *(struct __ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:УниверсальныйЗапрос", -1, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *type)
{
	size_t soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, "ns1:УниверсальныйЗапрос", &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag?tag:"-ns1:УниверсальныйЗапрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)p = *(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:УниверсальныйЗапросResponse", -1, &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	size_t soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, "ns1:УниверсальныйЗапросResponse", &a->ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag?tag:"-ns1:УниверсальныйЗапросResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)p = *(struct __ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, int id, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, "ns1:ТоварыВПути", -1, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC4 soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a, const char *type)
{
	size_t soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, "ns1:ТоварыВПути", &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, ""))
				{	soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag?tag:"-ns1:ТоварыВПути", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC4 soap_get___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 * SOAP_FMAC2 soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
		if (size)
			*size = sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 %p -> %p\n", q, p));
	*(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)p = *(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, "ns1:ТоварыВПутиResponse", -1, &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC4 soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a, const char *type)
{
	size_t soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, "ns1:ТоварыВПутиResponse", &a->ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, ""))
				{	soap_flag_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag?tag:"-ns1:ТоварыВПутиResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC4 soap_get___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response * SOAP_FMAC2 soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
		if (size)
			*size = sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response %p -> %p\n", q, p));
	*(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)p = *(struct __ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:РасчитатьАномальныйСпрос", -1, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:РасчитатьАномальныйСпрос", &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag?tag:"-ns1:РасчитатьАномальныйСпрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p = *(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:РасчитатьАномальныйСпросResponse", -1, &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	size_t soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:РасчитатьАномальныйСпросResponse", &a->ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag?tag:"-ns1:РасчитатьАномальныйСпросResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p = *(struct __ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, "ns1:Продажи", -1, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC4 soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, "ns1:Продажи", &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, ""))
				{	soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag?tag:"-ns1:Продажи", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC4 soap_get___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 * SOAP_FMAC2 soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
		if (size)
			*size = sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 %p -> %p\n", q, p));
	*(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)p = *(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, "ns1:ПродажиResponse", -1, &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC4 soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, "ns1:ПродажиResponse", &a->ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, ""))
				{	soap_flag_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag?tag:"-ns1:ПродажиResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC4 soap_get___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response * SOAP_FMAC2 soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
		if (size)
			*size = sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response %p -> %p\n", q, p));
	*(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)p = *(struct __ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, "ns1:ПолучитьЦеныНоменклатуры", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, "ns1:ПолучитьЦеныНоменклатуры", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag?tag:"-ns1:ПолучитьЦеныНоменклатуры", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, "ns1:ПолучитьЦеныНоменклатурыResponse", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, "ns1:ПолучитьЦеныНоменклатурыResponse", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag?tag:"-ns1:ПолучитьЦеныНоменклатурыResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, "ns1:ПолучитьКурсыВалют", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, "ns1:ПолучитьКурсыВалют", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag?tag:"-ns1:ПолучитьКурсыВалют", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, "ns1:ПолучитьКурсыВалютResponse", -1, &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC4 soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a, const char *type)
{
	size_t soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response = 1;
	short soap_flag;
	a = (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, "ns1:ПолучитьКурсыВалютResponse", &a->ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, ""))
				{	soap_flag_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag?tag:"-ns1:ПолучитьКурсыВалютResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC4 soap_get___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response * SOAP_FMAC2 soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
		if (size)
			*size = sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response %p -> %p\n", q, p));
	*(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)p = *(struct __ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, int id, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, "ns1:Остатки", -1, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC4 soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a, const char *type)
{
	size_t soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 = 1;
	short soap_flag;
	a = (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, "ns1:Остатки", &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, ""))
				{	soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag?tag:"-ns1:Остатки", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC4 soap_get___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 * SOAP_FMAC2 soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
		if (size)
			*size = sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 %p -> %p\n", q, p));
	*(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)p = *(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, "ns1:ОстаткиResponse", -1, &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC4 soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a, const char *type)
{
	size_t soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response = 1;
	short soap_flag;
	a = (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, "ns1:ОстаткиResponse", &a->ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, ""))
				{	soap_flag_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag?tag:"-ns1:ОстаткиResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC4 soap_get___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response * SOAP_FMAC2 soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
		if (size)
			*size = sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response %p -> %p\n", q, p));
	*(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)p = *(struct __ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:НеВыполненныйСпрос", -1, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *type)
{
	size_t soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 = 1;
	short soap_flag;
	a = (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, "ns1:НеВыполненныйСпрос", &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, ""))
				{	soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag?tag:"-ns1:НеВыполненныйСпрос", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC4 soap_get___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 * SOAP_FMAC2 soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
		if (size)
			*size = sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 %p -> %p\n", q, p));
	*(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)p = *(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:НеВыполненныйСпросResponse", -1, &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *type)
{
	size_t soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response = 1;
	short soap_flag;
	a = (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, "ns1:НеВыполненныйСпросResponse", &a->ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, ""))
				{	soap_flag_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag?tag:"-ns1:НеВыполненныйСпросResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC4 soap_get___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response * SOAP_FMAC2 soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
		if (size)
			*size = sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, n);
		if (size)
			*size = n * sizeof(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response %p -> %p\n", q, p));
	*(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)p = *(struct __ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, int id, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, "ns1:ИнформационныеБазы", -1, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC4 soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a, const char *type)
{
	size_t soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b = 1;
	short soap_flag;
	a = (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, "ns1:ИнформационныеБазы", &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, ""))
				{	soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag?tag:"-ns1:ИнформационныеБазы", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC4 soap_get___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b * SOAP_FMAC2 soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
		if (size)
			*size = sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b %p -> %p\n", q, p));
	*(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)p = *(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, int id, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, "ns1:ИнформационныеБазыResponse", -1, &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC4 soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a, const char *type)
{
	size_t soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, "ns1:ИнформационныеБазыResponse", &a->ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, ""))
				{	soap_flag_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag?tag:"-ns1:ИнформационныеБазыResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC4 soap_get___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse * SOAP_FMAC2 soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
		if (size)
			*size = sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse %p -> %p\n", q, p));
	*(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)p = *(struct __ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, int id, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, "ns1:ДниОтсутствия", -1, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC4 soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a, const char *type)
{
	size_t soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f = 1;
	short soap_flag;
	a = (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, "ns1:ДниОтсутствия", &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, ""))
				{	soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag?tag:"-ns1:ДниОтсутствия", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC4 soap_get___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f * SOAP_FMAC2 soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
		if (size)
			*size = sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f %p -> %p\n", q, p));
	*(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)p = *(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, int id, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, "ns1:ДниОтсутствияResponse", -1, &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC4 soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a, const char *type)
{
	size_t soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse = 1;
	short soap_flag;
	a = (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, "ns1:ДниОтсутствияResponse", &a->ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, ""))
				{	soap_flag_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag?tag:"-ns1:ДниОтсутствияResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC4 soap_get___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse * SOAP_FMAC2 soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
		if (size)
			*size = sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse %p -> %p\n", q, p));
	*(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)p = *(struct __ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStructureInfo(struct soap *soap, struct __ns1__GetStructureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStructureInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStructureInfo(struct soap *soap, const struct __ns1__GetStructureInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStructureInfo(soap, &a->ns1__GetStructureInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStructureInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetStructureInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetStructureInfo(soap, "ns1:GetStructureInfo", -1, &a->ns1__GetStructureInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStructureInfo * SOAP_FMAC4 soap_in___ns1__GetStructureInfo(struct soap *soap, const char *tag, struct __ns1__GetStructureInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetStructureInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetStructureInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStructureInfo, sizeof(struct __ns1__GetStructureInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStructureInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStructureInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStructureInfo(soap, "ns1:GetStructureInfo", &a->ns1__GetStructureInfo, ""))
				{	soap_flag_ns1__GetStructureInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStructureInfo(struct soap *soap, const struct __ns1__GetStructureInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetStructureInfo(soap, tag?tag:"-ns1:GetStructureInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStructureInfo * SOAP_FMAC4 soap_get___ns1__GetStructureInfo(struct soap *soap, struct __ns1__GetStructureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStructureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetStructureInfo * SOAP_FMAC2 soap_instantiate___ns1__GetStructureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStructureInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetStructureInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetStructureInfo);
		if (size)
			*size = sizeof(struct __ns1__GetStructureInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetStructureInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetStructureInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetStructureInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetStructureInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetStructureInfo %p -> %p\n", q, p));
	*(struct __ns1__GetStructureInfo*)p = *(struct __ns1__GetStructureInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAmountGoods(struct soap *soap, struct __ns1__GetAmountGoods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAmountGoods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAmountGoods(struct soap *soap, const struct __ns1__GetAmountGoods *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAmountGoods(soap, &a->ns1__GetAmountGoods);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAmountGoods(struct soap *soap, const char *tag, int id, const struct __ns1__GetAmountGoods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAmountGoods(soap, "ns1:GetAmountGoods", -1, &a->ns1__GetAmountGoods, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAmountGoods * SOAP_FMAC4 soap_in___ns1__GetAmountGoods(struct soap *soap, const char *tag, struct __ns1__GetAmountGoods *a, const char *type)
{
	size_t soap_flag_ns1__GetAmountGoods = 1;
	short soap_flag;
	a = (struct __ns1__GetAmountGoods *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAmountGoods, sizeof(struct __ns1__GetAmountGoods), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAmountGoods(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAmountGoods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAmountGoods(soap, "ns1:GetAmountGoods", &a->ns1__GetAmountGoods, ""))
				{	soap_flag_ns1__GetAmountGoods--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAmountGoods(struct soap *soap, const struct __ns1__GetAmountGoods *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAmountGoods(soap, tag?tag:"-ns1:GetAmountGoods", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAmountGoods * SOAP_FMAC4 soap_get___ns1__GetAmountGoods(struct soap *soap, struct __ns1__GetAmountGoods *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAmountGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAmountGoods * SOAP_FMAC2 soap_instantiate___ns1__GetAmountGoods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAmountGoods(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAmountGoods, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAmountGoods);
		if (size)
			*size = sizeof(struct __ns1__GetAmountGoods);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAmountGoods, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAmountGoods);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAmountGoods*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAmountGoods(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAmountGoods %p -> %p\n", q, p));
	*(struct __ns1__GetAmountGoods*)p = *(struct __ns1__GetAmountGoods*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryUniversalResponse(struct soap *soap, _ns1__QueryUniversalResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryUniversalResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryUniversalResponse(struct soap *soap, const char *tag, int id, _ns1__QueryUniversalResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryUniversalResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QueryUniversalResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryUniversalResponse(struct soap *soap, const char *tag, _ns1__QueryUniversalResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryUniversalResponse **)soap_malloc(soap, sizeof(_ns1__QueryUniversalResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryUniversalResponse *)soap_instantiate__ns1__QueryUniversalResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__QueryUniversalResponse ** p = (_ns1__QueryUniversalResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryUniversalResponse, sizeof(_ns1__QueryUniversalResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryUniversalResponse(struct soap *soap, _ns1__QueryUniversalResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__QueryUniversalResponse);
	if (soap_out_PointerTo_ns1__QueryUniversalResponse(soap, tag?tag:"ns1:QueryUniversalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryUniversalResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryUniversalResponse(struct soap *soap, _ns1__QueryUniversalResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryUniversalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryUniversal(struct soap *soap, _ns1__QueryUniversal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryUniversal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryUniversal(struct soap *soap, const char *tag, int id, _ns1__QueryUniversal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryUniversal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QueryUniversal ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryUniversal(struct soap *soap, const char *tag, _ns1__QueryUniversal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryUniversal **)soap_malloc(soap, sizeof(_ns1__QueryUniversal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryUniversal *)soap_instantiate__ns1__QueryUniversal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__QueryUniversal ** p = (_ns1__QueryUniversal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryUniversal, sizeof(_ns1__QueryUniversal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryUniversal(struct soap *soap, _ns1__QueryUniversal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__QueryUniversal);
	if (soap_out_PointerTo_ns1__QueryUniversal(soap, tag?tag:"ns1:QueryUniversal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryUniversal ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryUniversal(struct soap *soap, _ns1__QueryUniversal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryUniversal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, int id, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, const char *tag, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response **)soap_malloc(soap, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *)soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response ** p = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response);
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag?tag:"ns1:ЗаписатьДанныеResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, int id, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, const char *tag, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 **)soap_malloc(soap, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *)soap_instantiate__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 ** p = (_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435, sizeof(_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435);
	if (soap_out_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag?tag:"ns1:ЗаписатьДанные", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(struct soap *soap, _ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0417_x0430_x043f_x0438_x0441_x0430_x0442_x044c_x0414_x0430_x043d_x043d_x044b_x0435(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, int id, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse **)soap_malloc(soap, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse ** p = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse);
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag?tag:"ns1:ЦеныНоменклатурыПоПериодамResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043cResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, int id, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c **)soap_malloc(soap, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c ** p = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c);
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag?tag:"ns1:ЦеныНоменклатурыПоПериодам", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x041f_x0435_x0440_x0438_x043e_x0434_x0430_x043c(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, int id, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response **)soap_malloc(soap, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response ** p = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response);
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag?tag:"ns1:ЦеныНоменклатурыПоГТДResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, int id, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, const char *tag, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 **)soap_malloc(soap, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *)soap_instantiate__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 ** p = (_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414, sizeof(_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414);
	if (soap_out_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag?tag:"ns1:ЦеныНоменклатурыПоГТД", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(struct soap *soap, _ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b_x041f_x043e_x0413_x0422_x0414(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **)soap_malloc(soap, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** p = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag?tag:"ns1:РасширенныйЗапросResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **)soap_malloc(soap, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_instantiate__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** p = (_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag?tag:"ns1:РасширенныйЗапрос", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0420_x0430_x0441_x0448_x0438_x0440_x0435_x043d_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **)soap_malloc(soap, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *)soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** p = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response);
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag?tag:"ns1:УниверсальныйЗапросResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **)soap_malloc(soap, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *)soap_instantiate__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** p = (_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441, sizeof(_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441);
	if (soap_out_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag?tag:"ns1:УниверсальныйЗапрос", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0423_x043d_x0438_x0432_x0435_x0440_x0441_x0430_x043b_x044c_x043d_x044b_x0439_x0417_x0430_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, int id, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, const char *tag, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response **)soap_malloc(soap, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *)soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response ** p = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response);
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag?tag:"ns1:ТоварыВПутиResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, int id, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, const char *tag, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 **)soap_malloc(soap, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *)soap_instantiate__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 ** p = (_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438, sizeof(_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438);
	if (soap_out_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag?tag:"ns1:ТоварыВПути", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(struct soap *soap, _ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0422_x043e_x0432_x0430_x0440_x044b_x0412_x041f_x0443_x0442_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **)soap_malloc(soap, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** p = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag?tag:"ns1:РасчитатьАномальныйСпросResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **)soap_malloc(soap, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_instantiate__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** p = (_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (soap_out_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag?tag:"ns1:РасчитатьАномальныйСпрос", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0420_x0430_x0441_x0447_x0438_x0442_x0430_x0442_x044c_x0410_x043d_x043e_x043c_x0430_x043b_x044c_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, int id, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, const char *tag, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response **)soap_malloc(soap, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *)soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response ** p = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response);
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag?tag:"ns1:ПродажиResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, int id, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, const char *tag, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 **)soap_malloc(soap, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *)soap_instantiate__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 ** p = (_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438, sizeof(_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438);
	if (soap_out_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag?tag:"ns1:Продажи", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(struct soap *soap, _ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x0440_x043e_x0434_x0430_x0436_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, int id, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse **)soap_malloc(soap, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse ** p = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse);
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag?tag:"ns1:ПолучитьЦеныНоменклатурыResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, int id, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b **)soap_malloc(soap, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b ** p = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b);
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag?tag:"ns1:ПолучитьЦеныНоменклатуры", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x0426_x0435_x043d_x044b_x041d_x043e_x043c_x0435_x043d_x043a_x043b_x0430_x0442_x0443_x0440_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, int id, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response **)soap_malloc(soap, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response ** p = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response);
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag?tag:"ns1:ПолучитьКурсыВалютResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, int id, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, const char *tag, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 **)soap_malloc(soap, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *)soap_instantiate__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 ** p = (_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442, sizeof(_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442);
	if (soap_out_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag?tag:"ns1:ПолучитьКурсыВалют", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(struct soap *soap, _ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041f_x043e_x043b_x0443_x0447_x0438_x0442_x044c_x041a_x0443_x0440_x0441_x044b_x0412_x0430_x043b_x044e_x0442(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, int id, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, const char *tag, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response **)soap_malloc(soap, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *)soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response ** p = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response);
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag?tag:"ns1:ОстаткиResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, int id, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, const char *tag, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 **)soap_malloc(soap, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *)soap_instantiate__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 ** p = (_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438, sizeof(_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438);
	if (soap_out_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag?tag:"ns1:Остатки", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(struct soap *soap, _ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041e_x0441_x0442_x0430_x0442_x043a_x0438(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, int id, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, const char *tag, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **)soap_malloc(soap, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *)soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** p = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response);
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag?tag:"ns1:НеВыполненныйСпросResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, int id, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, const char *tag, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **)soap_malloc(soap, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *)soap_instantiate__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** p = (_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441, sizeof(_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441);
	if (soap_out_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag?tag:"ns1:НеВыполненныйСпрос", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 ** SOAP_FMAC4 soap_get_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(struct soap *soap, _ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x041d_x0435_x0412_x044b_x043f_x043e_x043b_x043d_x0435_x043d_x043d_x044b_x0439_x0421_x043f_x0440_x043e_x0441(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, int id, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, const char *tag, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse **)soap_malloc(soap, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *)soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse ** p = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse);
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag?tag:"ns1:ИнформационныеБазыResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044bResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, int id, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, const char *tag, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b **)soap_malloc(soap, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *)soap_instantiate__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b ** p = (_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b, sizeof(_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b);
	if (soap_out_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag?tag:"ns1:ИнформационныеБазы", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(struct soap *soap, _ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0418_x043d_x0444_x043e_x0440_x043c_x0430_x0446_x0438_x043e_x043d_x043d_x044b_x0435_x0411_x0430_x0437_x044b(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, int id, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, const char *tag, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse **)soap_malloc(soap, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *)soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse ** p = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse);
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag?tag:"ns1:ДниОтсутствияResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044fResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, int id, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f ** SOAP_FMAC4 soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, const char *tag, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f **)soap_malloc(soap, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *)soap_instantiate__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f ** p = (_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f, sizeof(_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f);
	if (soap_out_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag?tag:"ns1:ДниОтсутствия", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f ** SOAP_FMAC4 soap_get_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(struct soap *soap, _ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1___x0414_x043d_x0438_x041e_x0442_x0441_x0443_x0442_x0441_x0442_x0432_x0438_x044f(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStructureInfoResponse(struct soap *soap, _ns1__GetStructureInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStructureInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStructureInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetStructureInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStructureInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStructureInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStructureInfoResponse(struct soap *soap, const char *tag, _ns1__GetStructureInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStructureInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetStructureInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStructureInfoResponse *)soap_instantiate__ns1__GetStructureInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStructureInfoResponse ** p = (_ns1__GetStructureInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStructureInfoResponse, sizeof(_ns1__GetStructureInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStructureInfoResponse(struct soap *soap, _ns1__GetStructureInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStructureInfoResponse);
	if (soap_out_PointerTo_ns1__GetStructureInfoResponse(soap, tag?tag:"ns1:GetStructureInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStructureInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStructureInfoResponse(struct soap *soap, _ns1__GetStructureInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStructureInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStructureInfo(struct soap *soap, _ns1__GetStructureInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStructureInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStructureInfo(struct soap *soap, const char *tag, int id, _ns1__GetStructureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStructureInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStructureInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStructureInfo(struct soap *soap, const char *tag, _ns1__GetStructureInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStructureInfo **)soap_malloc(soap, sizeof(_ns1__GetStructureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStructureInfo *)soap_instantiate__ns1__GetStructureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetStructureInfo ** p = (_ns1__GetStructureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStructureInfo, sizeof(_ns1__GetStructureInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStructureInfo(struct soap *soap, _ns1__GetStructureInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStructureInfo);
	if (soap_out_PointerTo_ns1__GetStructureInfo(soap, tag?tag:"ns1:GetStructureInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStructureInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStructureInfo(struct soap *soap, _ns1__GetStructureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStructureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAmountGoodsResponse(struct soap *soap, _ns1__GetAmountGoodsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAmountGoodsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAmountGoodsResponse(struct soap *soap, const char *tag, int id, _ns1__GetAmountGoodsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAmountGoodsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAmountGoodsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAmountGoodsResponse(struct soap *soap, const char *tag, _ns1__GetAmountGoodsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAmountGoodsResponse **)soap_malloc(soap, sizeof(_ns1__GetAmountGoodsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAmountGoodsResponse *)soap_instantiate__ns1__GetAmountGoodsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAmountGoodsResponse ** p = (_ns1__GetAmountGoodsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAmountGoodsResponse, sizeof(_ns1__GetAmountGoodsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAmountGoodsResponse(struct soap *soap, _ns1__GetAmountGoodsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAmountGoodsResponse);
	if (soap_out_PointerTo_ns1__GetAmountGoodsResponse(soap, tag?tag:"ns1:GetAmountGoodsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAmountGoodsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAmountGoodsResponse(struct soap *soap, _ns1__GetAmountGoodsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAmountGoodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAmountGoods(struct soap *soap, _ns1__GetAmountGoods *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAmountGoods))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAmountGoods(struct soap *soap, const char *tag, int id, _ns1__GetAmountGoods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAmountGoods);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAmountGoods ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAmountGoods(struct soap *soap, const char *tag, _ns1__GetAmountGoods **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAmountGoods **)soap_malloc(soap, sizeof(_ns1__GetAmountGoods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAmountGoods *)soap_instantiate__ns1__GetAmountGoods(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAmountGoods ** p = (_ns1__GetAmountGoods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAmountGoods, sizeof(_ns1__GetAmountGoods), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAmountGoods(struct soap *soap, _ns1__GetAmountGoods *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAmountGoods);
	if (soap_out_PointerTo_ns1__GetAmountGoods(soap, tag?tag:"ns1:GetAmountGoods", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAmountGoods ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAmountGoods(struct soap *soap, _ns1__GetAmountGoods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAmountGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTreeRow(struct soap *soap, ns2__ValueTreeRow *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTreeRow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTreeRow(struct soap *soap, const char *tag, int id, ns2__ValueTreeRow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTreeRow);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTreeRow ** SOAP_FMAC4 soap_in_PointerTons2__ValueTreeRow(struct soap *soap, const char *tag, ns2__ValueTreeRow **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTreeRow **)soap_malloc(soap, sizeof(ns2__ValueTreeRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTreeRow *)soap_instantiate_ns2__ValueTreeRow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTreeRow ** p = (ns2__ValueTreeRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTreeRow, sizeof(ns2__ValueTreeRow), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTreeRow(struct soap *soap, ns2__ValueTreeRow *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTreeRow);
	if (soap_out_PointerTons2__ValueTreeRow(soap, tag?tag:"ns2:ValueTreeRow", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTreeRow ** SOAP_FMAC4 soap_get_PointerTons2__ValueTreeRow(struct soap *soap, ns2__ValueTreeRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTreeRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTreeColumn(struct soap *soap, ns2__ValueTreeColumn *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTreeColumn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTreeColumn(struct soap *soap, const char *tag, int id, ns2__ValueTreeColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTreeColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTreeColumn ** SOAP_FMAC4 soap_in_PointerTons2__ValueTreeColumn(struct soap *soap, const char *tag, ns2__ValueTreeColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTreeColumn **)soap_malloc(soap, sizeof(ns2__ValueTreeColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTreeColumn *)soap_instantiate_ns2__ValueTreeColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTreeColumn ** p = (ns2__ValueTreeColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTreeColumn, sizeof(ns2__ValueTreeColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTreeColumn(struct soap *soap, ns2__ValueTreeColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTreeColumn);
	if (soap_out_PointerTons2__ValueTreeColumn(soap, tag?tag:"ns2:ValueTreeColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTreeColumn ** SOAP_FMAC4 soap_get_PointerTons2__ValueTreeColumn(struct soap *soap, ns2__ValueTreeColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTreeColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKEN))
		soap_serialize_xsd__NMTOKEN(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NMTOKEN);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NMTOKEN(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NMTOKEN(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NMTOKEN);
	if (soap_out_PointerToxsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTableRow(struct soap *soap, ns2__ValueTableRow *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTableRow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTableRow(struct soap *soap, const char *tag, int id, ns2__ValueTableRow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTableRow);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTableRow ** SOAP_FMAC4 soap_in_PointerTons2__ValueTableRow(struct soap *soap, const char *tag, ns2__ValueTableRow **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTableRow **)soap_malloc(soap, sizeof(ns2__ValueTableRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTableRow *)soap_instantiate_ns2__ValueTableRow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTableRow ** p = (ns2__ValueTableRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTableRow, sizeof(ns2__ValueTableRow), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTableRow(struct soap *soap, ns2__ValueTableRow *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTableRow);
	if (soap_out_PointerTons2__ValueTableRow(soap, tag?tag:"ns2:ValueTableRow", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTableRow ** SOAP_FMAC4 soap_get_PointerTons2__ValueTableRow(struct soap *soap, ns2__ValueTableRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTableRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTableIndex(struct soap *soap, ns2__ValueTableIndex *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTableIndex))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTableIndex(struct soap *soap, const char *tag, int id, ns2__ValueTableIndex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTableIndex);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTableIndex ** SOAP_FMAC4 soap_in_PointerTons2__ValueTableIndex(struct soap *soap, const char *tag, ns2__ValueTableIndex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTableIndex **)soap_malloc(soap, sizeof(ns2__ValueTableIndex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTableIndex *)soap_instantiate_ns2__ValueTableIndex(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTableIndex ** p = (ns2__ValueTableIndex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTableIndex, sizeof(ns2__ValueTableIndex), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTableIndex(struct soap *soap, ns2__ValueTableIndex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTableIndex);
	if (soap_out_PointerTons2__ValueTableIndex(soap, tag?tag:"ns2:ValueTableIndex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTableIndex ** SOAP_FMAC4 soap_get_PointerTons2__ValueTableIndex(struct soap *soap, ns2__ValueTableIndex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTableIndex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTableColumn(struct soap *soap, ns2__ValueTableColumn *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTableColumn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTableColumn(struct soap *soap, const char *tag, int id, ns2__ValueTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTableColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTableColumn ** SOAP_FMAC4 soap_in_PointerTons2__ValueTableColumn(struct soap *soap, const char *tag, ns2__ValueTableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTableColumn **)soap_malloc(soap, sizeof(ns2__ValueTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTableColumn *)soap_instantiate_ns2__ValueTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTableColumn ** p = (ns2__ValueTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTableColumn, sizeof(ns2__ValueTableColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTableColumn(struct soap *soap, ns2__ValueTableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTableColumn);
	if (soap_out_PointerTons2__ValueTableColumn(soap, tag?tag:"ns2:ValueTableColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTableColumn ** SOAP_FMAC4 soap_get_PointerTons2__ValueTableColumn(struct soap *soap, ns2__ValueTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueListItemType(struct soap *soap, ns2__ValueListItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueListItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueListItemType(struct soap *soap, const char *tag, int id, ns2__ValueListItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueListItemType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueListItemType ** SOAP_FMAC4 soap_in_PointerTons2__ValueListItemType(struct soap *soap, const char *tag, ns2__ValueListItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueListItemType **)soap_malloc(soap, sizeof(ns2__ValueListItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueListItemType *)soap_instantiate_ns2__ValueListItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueListItemType ** p = (ns2__ValueListItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueListItemType, sizeof(ns2__ValueListItemType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueListItemType(struct soap *soap, ns2__ValueListItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueListItemType);
	if (soap_out_PointerTons2__ValueListItemType(soap, tag?tag:"ns2:ValueListItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueListItemType ** SOAP_FMAC4 soap_get_PointerTons2__ValueListItemType(struct soap *soap, ns2__ValueListItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueListItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TypeDescription(struct soap *soap, ns2__TypeDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TypeDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TypeDescription(struct soap *soap, const char *tag, int id, ns2__TypeDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TypeDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TypeDescription ** SOAP_FMAC4 soap_in_PointerTons2__TypeDescription(struct soap *soap, const char *tag, ns2__TypeDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TypeDescription **)soap_malloc(soap, sizeof(ns2__TypeDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TypeDescription *)soap_instantiate_ns2__TypeDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__TypeDescription ** p = (ns2__TypeDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TypeDescription, sizeof(ns2__TypeDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TypeDescription(struct soap *soap, ns2__TypeDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TypeDescription);
	if (soap_out_PointerTons2__TypeDescription(soap, tag?tag:"ns2:TypeDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TypeDescription ** SOAP_FMAC4 soap_get_PointerTons2__TypeDescription(struct soap *soap, ns2__TypeDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TypeDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BinaryDataQualifiers(struct soap *soap, ns2__BinaryDataQualifiers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BinaryDataQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BinaryDataQualifiers(struct soap *soap, const char *tag, int id, ns2__BinaryDataQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BinaryDataQualifiers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BinaryDataQualifiers ** SOAP_FMAC4 soap_in_PointerTons2__BinaryDataQualifiers(struct soap *soap, const char *tag, ns2__BinaryDataQualifiers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BinaryDataQualifiers **)soap_malloc(soap, sizeof(ns2__BinaryDataQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BinaryDataQualifiers *)soap_instantiate_ns2__BinaryDataQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__BinaryDataQualifiers ** p = (ns2__BinaryDataQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BinaryDataQualifiers, sizeof(ns2__BinaryDataQualifiers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BinaryDataQualifiers(struct soap *soap, ns2__BinaryDataQualifiers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BinaryDataQualifiers);
	if (soap_out_PointerTons2__BinaryDataQualifiers(soap, tag?tag:"ns2:BinaryDataQualifiers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BinaryDataQualifiers ** SOAP_FMAC4 soap_get_PointerTons2__BinaryDataQualifiers(struct soap *soap, ns2__BinaryDataQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BinaryDataQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DateQualifiers(struct soap *soap, ns2__DateQualifiers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DateQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DateQualifiers(struct soap *soap, const char *tag, int id, ns2__DateQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DateQualifiers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DateQualifiers ** SOAP_FMAC4 soap_in_PointerTons2__DateQualifiers(struct soap *soap, const char *tag, ns2__DateQualifiers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DateQualifiers **)soap_malloc(soap, sizeof(ns2__DateQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DateQualifiers *)soap_instantiate_ns2__DateQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DateQualifiers ** p = (ns2__DateQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DateQualifiers, sizeof(ns2__DateQualifiers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DateQualifiers(struct soap *soap, ns2__DateQualifiers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DateQualifiers);
	if (soap_out_PointerTons2__DateQualifiers(soap, tag?tag:"ns2:DateQualifiers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DateQualifiers ** SOAP_FMAC4 soap_get_PointerTons2__DateQualifiers(struct soap *soap, ns2__DateQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DateQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StringQualifiers(struct soap *soap, ns2__StringQualifiers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StringQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StringQualifiers(struct soap *soap, const char *tag, int id, ns2__StringQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StringQualifiers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__StringQualifiers ** SOAP_FMAC4 soap_in_PointerTons2__StringQualifiers(struct soap *soap, const char *tag, ns2__StringQualifiers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__StringQualifiers **)soap_malloc(soap, sizeof(ns2__StringQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__StringQualifiers *)soap_instantiate_ns2__StringQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__StringQualifiers ** p = (ns2__StringQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StringQualifiers, sizeof(ns2__StringQualifiers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StringQualifiers(struct soap *soap, ns2__StringQualifiers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StringQualifiers);
	if (soap_out_PointerTons2__StringQualifiers(soap, tag?tag:"ns2:StringQualifiers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__StringQualifiers ** SOAP_FMAC4 soap_get_PointerTons2__StringQualifiers(struct soap *soap, ns2__StringQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StringQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NumberQualifiers(struct soap *soap, ns2__NumberQualifiers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NumberQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NumberQualifiers(struct soap *soap, const char *tag, int id, ns2__NumberQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NumberQualifiers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NumberQualifiers ** SOAP_FMAC4 soap_in_PointerTons2__NumberQualifiers(struct soap *soap, const char *tag, ns2__NumberQualifiers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NumberQualifiers **)soap_malloc(soap, sizeof(ns2__NumberQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NumberQualifiers *)soap_instantiate_ns2__NumberQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NumberQualifiers ** p = (ns2__NumberQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NumberQualifiers, sizeof(ns2__NumberQualifiers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NumberQualifiers(struct soap *soap, ns2__NumberQualifiers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NumberQualifiers);
	if (soap_out_PointerTons2__NumberQualifiers(soap, tag?tag:"ns2:NumberQualifiers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NumberQualifiers ** SOAP_FMAC4 soap_get_PointerTons2__NumberQualifiers(struct soap *soap, ns2__NumberQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NumberQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, std::vector<_ns2__Structure_Property >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property))
		soap_serialize_std__vectorTemplateOf_ns2__Structure_Property(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, const char *tag, int id, std::vector<_ns2__Structure_Property >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_ns2__Structure_Property(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns2__Structure_Property >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, const char *tag, std::vector<_ns2__Structure_Property >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_ns2__Structure_Property >**)soap_malloc(soap, sizeof(std::vector<_ns2__Structure_Property >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_ns2__Structure_Property(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, std::vector<_ns2__Structure_Property >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__Structure_Property);
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__Structure_Property(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns2__Structure_Property >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, std::vector<_ns2__Structure_Property >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_ns2__Structure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LocalStringItemType(struct soap *soap, ns2__LocalStringItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LocalStringItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LocalStringItemType(struct soap *soap, const char *tag, int id, ns2__LocalStringItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LocalStringItemType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LocalStringItemType ** SOAP_FMAC4 soap_in_PointerTons2__LocalStringItemType(struct soap *soap, const char *tag, ns2__LocalStringItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LocalStringItemType **)soap_malloc(soap, sizeof(ns2__LocalStringItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LocalStringItemType *)soap_instantiate_ns2__LocalStringItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LocalStringItemType ** p = (ns2__LocalStringItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LocalStringItemType, sizeof(ns2__LocalStringItemType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LocalStringItemType(struct soap *soap, ns2__LocalStringItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LocalStringItemType);
	if (soap_out_PointerTons2__LocalStringItemType(soap, tag?tag:"ns2:LocalStringItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LocalStringItemType ** SOAP_FMAC4 soap_get_PointerTons2__LocalStringItemType(struct soap *soap, ns2__LocalStringItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LocalStringItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GenericException(struct soap *soap, ns2__GenericException *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GenericException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GenericException(struct soap *soap, const char *tag, int id, ns2__GenericException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GenericException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GenericException ** SOAP_FMAC4 soap_in_PointerTons2__GenericException(struct soap *soap, const char *tag, ns2__GenericException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GenericException **)soap_malloc(soap, sizeof(ns2__GenericException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GenericException *)soap_instantiate_ns2__GenericException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GenericException ** p = (ns2__GenericException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GenericException, sizeof(ns2__GenericException), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__GenericException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Exception, sizeof(ns2__Exception), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GenericException(struct soap *soap, ns2__GenericException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GenericException);
	if (soap_out_PointerTons2__GenericException(soap, tag?tag:"ns2:GenericException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GenericException ** SOAP_FMAC4 soap_get_PointerTons2__GenericException(struct soap *soap, ns2__GenericException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GenericException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, std::vector<_ns2__FixedStructure_Property >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property))
		soap_serialize_std__vectorTemplateOf_ns2__FixedStructure_Property(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, const char *tag, int id, std::vector<_ns2__FixedStructure_Property >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_ns2__FixedStructure_Property(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_ns2__FixedStructure_Property >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, const char *tag, std::vector<_ns2__FixedStructure_Property >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_ns2__FixedStructure_Property >**)soap_malloc(soap, sizeof(std::vector<_ns2__FixedStructure_Property >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_ns2__FixedStructure_Property(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, std::vector<_ns2__FixedStructure_Property >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property);
	if (soap_out_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_ns2__FixedStructure_Property >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, std::vector<_ns2__FixedStructure_Property >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_ns2__FixedStructure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__KeyAndValue(struct soap *soap, ns2__KeyAndValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__KeyAndValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__KeyAndValue(struct soap *soap, const char *tag, int id, ns2__KeyAndValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__KeyAndValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__KeyAndValue ** SOAP_FMAC4 soap_in_PointerTons2__KeyAndValue(struct soap *soap, const char *tag, ns2__KeyAndValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__KeyAndValue **)soap_malloc(soap, sizeof(ns2__KeyAndValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__KeyAndValue *)soap_instantiate_ns2__KeyAndValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__KeyAndValue ** p = (ns2__KeyAndValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__KeyAndValue, sizeof(ns2__KeyAndValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__KeyAndValue(struct soap *soap, ns2__KeyAndValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__KeyAndValue);
	if (soap_out_PointerTons2__KeyAndValue(soap, tag?tag:"ns2:KeyAndValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__KeyAndValue ** SOAP_FMAC4 soap_get_PointerTons2__KeyAndValue(struct soap *soap, ns2__KeyAndValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__KeyAndValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DataFillError(struct soap *soap, ns2__DataFillError *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DataFillError))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DataFillError(struct soap *soap, const char *tag, int id, ns2__DataFillError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DataFillError);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DataFillError ** SOAP_FMAC4 soap_in_PointerTons2__DataFillError(struct soap *soap, const char *tag, ns2__DataFillError **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DataFillError **)soap_malloc(soap, sizeof(ns2__DataFillError *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DataFillError *)soap_instantiate_ns2__DataFillError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DataFillError ** p = (ns2__DataFillError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DataFillError, sizeof(ns2__DataFillError), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DataFillError(struct soap *soap, ns2__DataFillError *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DataFillError);
	if (soap_out_PointerTons2__DataFillError(soap, tag?tag:"ns2:DataFillError", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DataFillError ** SOAP_FMAC4 soap_get_PointerTons2__DataFillError(struct soap *soap, ns2__DataFillError **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DataFillError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag?tag:"wchar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTree(struct soap *soap, ns2__ValueTree *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTree))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTree(struct soap *soap, const char *tag, int id, ns2__ValueTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTree);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTree ** SOAP_FMAC4 soap_in_PointerTons2__ValueTree(struct soap *soap, const char *tag, ns2__ValueTree **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTree **)soap_malloc(soap, sizeof(ns2__ValueTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTree *)soap_instantiate_ns2__ValueTree(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTree ** p = (ns2__ValueTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTree, sizeof(ns2__ValueTree), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTree(struct soap *soap, ns2__ValueTree *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTree);
	if (soap_out_PointerTons2__ValueTree(soap, tag?tag:"ns2:ValueTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTree ** SOAP_FMAC4 soap_get_PointerTons2__ValueTree(struct soap *soap, ns2__ValueTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueListType(struct soap *soap, ns2__ValueListType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueListType(struct soap *soap, const char *tag, int id, ns2__ValueListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueListType ** SOAP_FMAC4 soap_in_PointerTons2__ValueListType(struct soap *soap, const char *tag, ns2__ValueListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueListType **)soap_malloc(soap, sizeof(ns2__ValueListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueListType *)soap_instantiate_ns2__ValueListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueListType ** p = (ns2__ValueListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueListType, sizeof(ns2__ValueListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueListType(struct soap *soap, ns2__ValueListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueListType);
	if (soap_out_PointerTons2__ValueListType(soap, tag?tag:"ns2:ValueListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueListType ** SOAP_FMAC4 soap_get_PointerTons2__ValueListType(struct soap *soap, ns2__ValueListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValueTable(struct soap *soap, ns2__ValueTable *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValueTable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValueTable(struct soap *soap, const char *tag, int id, ns2__ValueTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValueTable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValueTable ** SOAP_FMAC4 soap_in_PointerTons2__ValueTable(struct soap *soap, const char *tag, ns2__ValueTable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValueTable **)soap_malloc(soap, sizeof(ns2__ValueTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValueTable *)soap_instantiate_ns2__ValueTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValueTable ** p = (ns2__ValueTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValueTable, sizeof(ns2__ValueTable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValueTable(struct soap *soap, ns2__ValueTable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValueTable);
	if (soap_out_PointerTons2__ValueTable(soap, tag?tag:"ns2:ValueTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValueTable ** SOAP_FMAC4 soap_get_PointerTons2__ValueTable(struct soap *soap, ns2__ValueTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValueTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Structure(struct soap *soap, ns2__Structure *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Structure))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Structure(struct soap *soap, const char *tag, int id, ns2__Structure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Structure);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Structure ** SOAP_FMAC4 soap_in_PointerTons2__Structure(struct soap *soap, const char *tag, ns2__Structure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Structure **)soap_malloc(soap, sizeof(ns2__Structure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Structure *)soap_instantiate_ns2__Structure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Structure ** p = (ns2__Structure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Structure, sizeof(ns2__Structure), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Structure(struct soap *soap, ns2__Structure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Structure);
	if (soap_out_PointerTons2__Structure(soap, tag?tag:"ns2:Structure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Structure ** SOAP_FMAC4 soap_get_PointerTons2__Structure(struct soap *soap, ns2__Structure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Structure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Object(struct soap *soap, ns1__Object *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Object))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Object(struct soap *soap, const char *tag, int id, ns1__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Object);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Object ** SOAP_FMAC4 soap_in_PointerTons1__Object(struct soap *soap, const char *tag, ns1__Object **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Object **)soap_malloc(soap, sizeof(ns1__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Object *)soap_instantiate_ns1__Object(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Object ** p = (ns1__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Object, sizeof(ns1__Object), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Object(struct soap *soap, ns1__Object *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Object);
	if (soap_out_PointerTons1__Object(soap, tag?tag:"ns1:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Object ** SOAP_FMAC4 soap_get_PointerTons1__Object(struct soap *soap, ns1__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, std::vector<ns2__ValueTreeRow * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, const std::vector<ns2__ValueTreeRow * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueTreeRow * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueTreeRow(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueTreeRow * >*a, const char *type)
{
	for (std::vector<ns2__ValueTreeRow * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueTreeRow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueTreeRow * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, const char *tag, std::vector<ns2__ValueTreeRow * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueTreeRow *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueTreeRow, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeRow, sizeof(ns2__ValueTreeRow), 1))
				break;
			if (!soap_in_PointerTons2__ValueTreeRow(soap, tag, NULL, "ns2:ValueTreeRow"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueTreeRow(soap, tag, &n, "ns2:ValueTreeRow"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueTreeRow(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueTreeRow * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeRow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeRow, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueTreeRow * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueTreeRow * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueTreeRow * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueTreeRow * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueTreeRow * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueTreeRow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueTreeRow * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueTreeRow * >*)p = *(std::vector<ns2__ValueTreeRow * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, std::vector<ns2__ValueTreeColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, const std::vector<ns2__ValueTreeColumn * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueTreeColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueTreeColumn(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueTreeColumn * >*a, const char *type)
{
	for (std::vector<ns2__ValueTreeColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueTreeColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueTreeColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, const char *tag, std::vector<ns2__ValueTreeColumn * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueTreeColumn *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueTreeColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeColumn, sizeof(ns2__ValueTreeColumn), 1))
				break;
			if (!soap_in_PointerTons2__ValueTreeColumn(soap, tag, NULL, "ns2:ValueTreeColumn"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueTreeColumn(soap, tag, &n, "ns2:ValueTreeColumn"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueTreeColumn(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueTreeColumn * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTreeColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTreeColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueTreeColumn * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueTreeColumn * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueTreeColumn * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueTreeColumn * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueTreeColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueTreeColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueTreeColumn * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueTreeColumn * >*)p = *(std::vector<ns2__ValueTreeColumn * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__NMTOKEN(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__NMTOKEN(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__NMTOKEN(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__NMTOKEN, SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN, sizeof(std::wstring), 0))
				break;
			if (!soap_in_xsd__NMTOKEN(soap, tag, NULL, "xsd:NMTOKEN"))
				break;
		}
		else if (!soap_in_xsd__NMTOKEN(soap, tag, &n, "xsd:NMTOKEN"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__NMTOKEN(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, std::vector<ns2__ValueTableRow * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, const std::vector<ns2__ValueTableRow * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueTableRow * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueTableRow(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueTableRow * >*a, const char *type)
{
	for (std::vector<ns2__ValueTableRow * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueTableRow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueTableRow * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, const char *tag, std::vector<ns2__ValueTableRow * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueTableRow *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueTableRow, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableRow, sizeof(ns2__ValueTableRow), 1))
				break;
			if (!soap_in_PointerTons2__ValueTableRow(soap, tag, NULL, "ns2:ValueTableRow"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueTableRow(soap, tag, &n, "ns2:ValueTableRow"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueTableRow(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueTableRow * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableRow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableRow, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueTableRow * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueTableRow * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueTableRow * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueTableRow * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueTableRow * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueTableRow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueTableRow * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueTableRow * >*)p = *(std::vector<ns2__ValueTableRow * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, std::vector<ns2__ValueTableIndex * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, const std::vector<ns2__ValueTableIndex * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueTableIndex * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueTableIndex(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueTableIndex * >*a, const char *type)
{
	for (std::vector<ns2__ValueTableIndex * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueTableIndex(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueTableIndex * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, const char *tag, std::vector<ns2__ValueTableIndex * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueTableIndex *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueTableIndex, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableIndex, sizeof(ns2__ValueTableIndex), 1))
				break;
			if (!soap_in_PointerTons2__ValueTableIndex(soap, tag, NULL, "ns2:ValueTableIndex"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueTableIndex(soap, tag, &n, "ns2:ValueTableIndex"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueTableIndex(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueTableIndex * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableIndex(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableIndex, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueTableIndex * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueTableIndex * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueTableIndex * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueTableIndex * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueTableIndex * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueTableIndex(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueTableIndex * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueTableIndex * >*)p = *(std::vector<ns2__ValueTableIndex * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, std::vector<ns2__ValueTableColumn * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, const std::vector<ns2__ValueTableColumn * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueTableColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueTableColumn(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueTableColumn * >*a, const char *type)
{
	for (std::vector<ns2__ValueTableColumn * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueTableColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueTableColumn * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, const char *tag, std::vector<ns2__ValueTableColumn * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueTableColumn *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueTableColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableColumn, sizeof(ns2__ValueTableColumn), 1))
				break;
			if (!soap_in_PointerTons2__ValueTableColumn(soap, tag, NULL, "ns2:ValueTableColumn"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueTableColumn(soap, tag, &n, "ns2:ValueTableColumn"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueTableColumn(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueTableColumn * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueTableColumn * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueTableColumn * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueTableColumn * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueTableColumn * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueTableColumn * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueTableColumn * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueTableColumn * >*)p = *(std::vector<ns2__ValueTableColumn * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, std::vector<ns2__ValueListItemType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, const std::vector<ns2__ValueListItemType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__ValueListItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ValueListItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ValueListItemType * >*a, const char *type)
{
	for (std::vector<ns2__ValueListItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ValueListItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ValueListItemType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, const char *tag, std::vector<ns2__ValueListItemType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__ValueListItemType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ValueListItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueListItemType, sizeof(ns2__ValueListItemType), 1))
				break;
			if (!soap_in_PointerTons2__ValueListItemType(soap, tag, NULL, "ns2:ValueListItemType"))
				break;
		}
		else if (!soap_in_PointerTons2__ValueListItemType(soap, tag, &n, "ns2:ValueListItemType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ValueListItemType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ValueListItemType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ValueListItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ValueListItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ValueListItemType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ValueListItemType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__ValueListItemType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__ValueListItemType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__ValueListItemType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ValueListItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ValueListItemType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ValueListItemType * >*)p = *(std::vector<ns2__ValueListItemType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__UUID(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__UUID(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns2__UUID(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__UUID(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__UUID(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__UUID(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_ns2__UUID(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__UUID, SOAP_TYPE_std__vectorTemplateOfns2__UUID, sizeof(std::string), 0))
				break;
			if (!soap_in_ns2__UUID(soap, tag, NULL, "ns2:UUID"))
				break;
		}
		else if (!soap_in_ns2__UUID(soap, tag, &n, "ns2:UUID"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfns2__UUID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__UUID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__UUID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__UUID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__UUID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__QName(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, std::vector<_ns2__Structure_Property >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, const std::vector<_ns2__Structure_Property >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__Structure_Property >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, const char *tag, int id, const std::vector<_ns2__Structure_Property >*a, const char *type)
{
	for (std::vector<_ns2__Structure_Property >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__Structure_Property >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, const char *tag, std::vector<_ns2__Structure_Property >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__Structure_Property n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__Structure_Property, SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property, sizeof(_ns2__Structure_Property), 0))
				break;
			if (!soap_in__ns2__Structure_Property(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__ns2__Structure_Property(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__Structure_Property(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__Structure_Property > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__Structure_Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_ns2__Structure_Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__Structure_Property >);
		if (size)
			*size = sizeof(std::vector<_ns2__Structure_Property >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__Structure_Property >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__Structure_Property >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__Structure_Property >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns2__Structure_Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__Structure_Property > %p -> %p\n", q, p));
	*(std::vector<_ns2__Structure_Property >*)p = *(std::vector<_ns2__Structure_Property >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, std::vector<ns2__LocalStringItemType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, const std::vector<ns2__LocalStringItemType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__LocalStringItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__LocalStringItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, const char *tag, int id, const std::vector<ns2__LocalStringItemType * >*a, const char *type)
{
	for (std::vector<ns2__LocalStringItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__LocalStringItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__LocalStringItemType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, const char *tag, std::vector<ns2__LocalStringItemType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__LocalStringItemType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__LocalStringItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocalStringItemType, sizeof(ns2__LocalStringItemType), 1))
				break;
			if (!soap_in_PointerTons2__LocalStringItemType(soap, tag, NULL, "ns2:LocalStringItemType"))
				break;
		}
		else if (!soap_in_PointerTons2__LocalStringItemType(soap, tag, &n, "ns2:LocalStringItemType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__LocalStringItemType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__LocalStringItemType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__LocalStringItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocalStringItemType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__LocalStringItemType * >);
		if (size)
			*size = sizeof(std::vector<ns2__LocalStringItemType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__LocalStringItemType * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__LocalStringItemType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__LocalStringItemType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__LocalStringItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__LocalStringItemType * > %p -> %p\n", q, p));
	*(std::vector<ns2__LocalStringItemType * >*)p = *(std::vector<ns2__LocalStringItemType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, std::vector<_ns2__FixedStructure_Property >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, const std::vector<_ns2__FixedStructure_Property >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__FixedStructure_Property >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, const char *tag, int id, const std::vector<_ns2__FixedStructure_Property >*a, const char *type)
{
	for (std::vector<_ns2__FixedStructure_Property >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__FixedStructure_Property >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, const char *tag, std::vector<_ns2__FixedStructure_Property >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_ns2__FixedStructure_Property n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__ns2__FixedStructure_Property, SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property, sizeof(_ns2__FixedStructure_Property), 0))
				break;
			if (!soap_in__ns2__FixedStructure_Property(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__ns2__FixedStructure_Property(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__FixedStructure_Property(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__FixedStructure_Property > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__FixedStructure_Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_ns2__FixedStructure_Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_ns2__FixedStructure_Property >);
		if (size)
			*size = sizeof(std::vector<_ns2__FixedStructure_Property >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_ns2__FixedStructure_Property >, n);
		if (size)
			*size = n * sizeof(std::vector<_ns2__FixedStructure_Property >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_ns2__FixedStructure_Property >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_ns2__FixedStructure_Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_ns2__FixedStructure_Property > %p -> %p\n", q, p));
	*(std::vector<_ns2__FixedStructure_Property >*)p = *(std::vector<_ns2__FixedStructure_Property >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, std::vector<ns2__KeyAndValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, const std::vector<ns2__KeyAndValue * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__KeyAndValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__KeyAndValue(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, const char *tag, int id, const std::vector<ns2__KeyAndValue * >*a, const char *type)
{
	for (std::vector<ns2__KeyAndValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__KeyAndValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__KeyAndValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, const char *tag, std::vector<ns2__KeyAndValue * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__KeyAndValue *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__KeyAndValue, SOAP_TYPE_std__vectorTemplateOfPointerTons2__KeyAndValue, sizeof(ns2__KeyAndValue), 1))
				break;
			if (!soap_in_PointerTons2__KeyAndValue(soap, tag, NULL, "ns2:KeyAndValue"))
				break;
		}
		else if (!soap_in_PointerTons2__KeyAndValue(soap, tag, &n, "ns2:KeyAndValue"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__KeyAndValue(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__KeyAndValue * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__KeyAndValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__KeyAndValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__KeyAndValue * >);
		if (size)
			*size = sizeof(std::vector<ns2__KeyAndValue * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__KeyAndValue * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__KeyAndValue * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__KeyAndValue * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__KeyAndValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__KeyAndValue * > %p -> %p\n", q, p));
	*(std::vector<ns2__KeyAndValue * >*)p = *(std::vector<ns2__KeyAndValue * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	char *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else if (!soap_inliteral(soap, tag, &n))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<char * >, n);
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, std::vector<ns2__DataFillError * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, const std::vector<ns2__DataFillError * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__DataFillError * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DataFillError(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, const char *tag, int id, const std::vector<ns2__DataFillError * >*a, const char *type)
{
	for (std::vector<ns2__DataFillError * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DataFillError(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DataFillError * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, const char *tag, std::vector<ns2__DataFillError * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__DataFillError *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DataFillError, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataFillError, sizeof(ns2__DataFillError), 1))
				break;
			if (!soap_in_PointerTons2__DataFillError(soap, tag, NULL, "ns2:DataFillError"))
				break;
		}
		else if (!soap_in_PointerTons2__DataFillError(soap, tag, &n, "ns2:DataFillError"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DataFillError(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DataFillError * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DataFillError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DataFillError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DataFillError * >);
		if (size)
			*size = sizeof(std::vector<ns2__DataFillError * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__DataFillError * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__DataFillError * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__DataFillError * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__DataFillError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__DataFillError * > %p -> %p\n", q, p));
	*(std::vector<ns2__DataFillError * >*)p = *(std::vector<ns2__DataFillError * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwstring(struct soap *soap, std::vector<wchar_t * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwstring(struct soap *soap, const std::vector<wchar_t * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<wchar_t * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwstring(struct soap *soap, const char *tag, int id, const std::vector<wchar_t * >*a, const char *type)
{
	for (std::vector<wchar_t * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_wstring(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wchar_t * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfwstring(struct soap *soap, const char *tag, std::vector<wchar_t * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	wchar_t *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_wstring, SOAP_TYPE_std__vectorTemplateOfwstring, sizeof(wchar_t *), 1))
				break;
			if (!soap_in_wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_wstring(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfwstring(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wchar_t * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfwstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfwstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfwstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wchar_t * >);
		if (size)
			*size = sizeof(std::vector<wchar_t * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<wchar_t * >, n);
		if (size)
			*size = n * sizeof(std::vector<wchar_t * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<wchar_t * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfwstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<wchar_t * > %p -> %p\n", q, p));
	*(std::vector<wchar_t * >*)p = *(std::vector<wchar_t * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, std::vector<ns1__Object * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, const std::vector<ns1__Object * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Object * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Object(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, const char *tag, int id, const std::vector<ns1__Object * >*a, const char *type)
{
	for (std::vector<ns1__Object * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Object(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Object * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, const char *tag, std::vector<ns1__Object * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__Object *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Object, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Object, sizeof(ns1__Object), 1))
				break;
			if (!soap_in_PointerTons1__Object(soap, tag, NULL, "ns1:Object"))
				break;
		}
		else if (!soap_in_PointerTons1__Object(soap, tag, &n, "ns1:Object"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Object(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Object * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Object * >);
		if (size)
			*size = sizeof(std::vector<ns1__Object * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__Object * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__Object * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__Object * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Object * > %p -> %p\n", q, p));
	*(std::vector<ns1__Object * >*)p = *(std::vector<ns1__Object * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
